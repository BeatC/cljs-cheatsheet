{
  "cljs.core\/apply": {
    "signature": [
      "[f args]",
      "[f x args]",
      "[f x y args]",
      "[f x y z args]",
      "[f a b c d & args]"
    ],
    "related": [
      "cljs.core\/map"
    ],
    "todo": "This needs an example.",
    "full-name": "cljs.core\/apply",
    "description-html": "<p>Applies function <code>f<\/code> to the argument list formed by prepending intervening\narguments to <code>args<\/code>.<\/p>"
  },
  "cljs.core\/->": {
    "type": "macro",
    "signature": [
      "[x & forms]"
    ],
    "related": [
      "cljs.core\/->>"
    ],
    "todo": "add threading macro animations link here",
    "full-name": "cljs.core\/->",
    "description-html": "<p>The thread-first macro &quot;threads&quot; an expression through several forms as the\nsecond item in a list.<\/p>\n<p>Inserts <code>x<\/code> as the second item in the first form, making a list of it if it is\nnot a list already. If there are more forms, inserts the first form as the\nsecond item in second form, etc.<\/p>\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code<\/th>\n      <th>Expands To<\/th><\/tr><\/thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(-&gt; x\n  (a b c)\n  d\n  (x y z))<\/pre><\/td>\n      <td><pre>\n(x (d (a x b c)) y z)<\/pre><\/td><\/tr><\/tbody><\/table>"
  },
  "cljs.core\/lazy-cat": {
    "type": "macro",
    "signature": [
      "[& colls]"
    ],
    "related": [
      "cljs.core\/lazy-seq",
      "cljs.core\/concat"
    ],
    "full-name": "cljs.core\/lazy-cat",
    "description-html": "<p>Expands to code which yields a lazy sequence of the concatenation of the\nsupplied collections. Each collections expression is not evaluated until it is\nneeded.<\/p>\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code<\/th>\n      <th>Expands To<\/th><\/tr><\/thead>\n  <tbody>\n    <tr>\n      <td><code>(lazy-cat x y z)<\/code>\n      <td><pre>\n(concat (lazy-seq x)\n        (lazy-seq y)\n        (lazy-seq z))<\/pre><\/td><\/tr><\/tbody><\/table>"
  },
  "cljs.core\/identity": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/nil?"
    ],
    "todo": "Would be nice to provide a quick explanation as to why this function can be\nuseful.",
    "full-name": "cljs.core\/identity",
    "description-html": "<p>Returns its argument.<\/p>"
  },
  "cljs.core\/count": {
    "signature": [
      "[x]"
    ],
    "full-name": "cljs.core\/count",
    "description-html": "<p>Returns the number of items in <code>x<\/code>.<\/p>\n<p><code>count<\/code> works on arrays, lists, maps, sets, strings, and vectors.<\/p>\n<p><code>(count nil)<\/code> returns 0.<\/p>"
  },
  "cljs.core\/deref": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/atom"
    ],
    "full-name": "cljs.core\/deref",
    "description-html": "<p>Returns the current value of atom <code>x<\/code>.<\/p>\n<p>The <code>@<\/code> reader macro is often used instead of <code>deref<\/code>. <code>@foo<\/code> is the same thing\nas <code>(deref foo)<\/code>.<\/p>"
  },
  "cljs.core\/hash-map": {
    "signature": [
      "[& keyvals]"
    ],
    "related": [
      "cljs.core\/array-map",
      "cljs.core\/sorted-map"
    ],
    "full-name": "cljs.core\/hash-map",
    "description-html": "<p>Returns a new hash map with supplied mappings.<\/p>\n<p><code>keyvals<\/code> must be an even number of forms.<\/p>"
  },
  "cljs.core\/keep-indexed": {
    "signature": [
      "[f]",
      "[f coll]"
    ],
    "related": [
      "cljs.core\/map-indexed",
      "cljs.core\/keep"
    ],
    "full-name": "cljs.core\/keep-indexed",
    "description-html": "<p>Returns a lazy sequence of the non-nil results of <code>(f index item)<\/code>. Note, this\nmeans false return values will be included.<\/p>\n<p>`f must be free of side-effects.<\/p>\n<p>Returns a stateful transducer when no collection is provided.<\/p>"
  },
  "cljs.core\/aset": {
    "signature": [
      "[array i val]",
      "[array idx idx2 & idxv]"
    ],
    "related": [
      "cljs.core\/aget",
      "cljs.core\/assoc-in"
    ],
    "full-name": "cljs.core\/aset",
    "description-html": "<p>Sets <code>val<\/code> at index <code>i<\/code> in JavaScript arrays and objects.<\/p>\n<p>Can be used to set nested properties in JavaScript objects, ie: <code>(aset\njs\/document &quot;location&quot; &quot;href&quot; &quot;http:\/\/cljs.info&quot;)<\/code><\/p>"
  },
  "cljs.core\/reduce": {
    "signature": [
      "[f coll]",
      "[f val coll]"
    ],
    "related": [
      "cljs.core\/reductions",
      "cljs.core\/apply",
      "cljs.core\/frequencies"
    ],
    "full-name": "cljs.core\/reduce",
    "description-html": "<p><code>f<\/code> should be a function of 2 arguments. If <code>val<\/code> is not supplied, returns the\nresult of applying <code>f<\/code> to the first 2 items in <code>coll<\/code>, then applying <code>f<\/code> to that\nresult and the 3rd item, etc.<\/p>\n<p>If <code>coll<\/code> contains no items, <code>f<\/code> must accept no arguments as well, and <code>reduce<\/code>\nreturns the result of calling <code>f<\/code> with no arguments.<\/p>\n<p>If <code>coll<\/code> has only 1 item, it is returned and <code>f<\/code> is not called.<\/p>\n<p>If <code>val<\/code> is supplied, returns the result of applying <code>f<\/code> to <code>val<\/code> and the first\nitem in <code>coll<\/code>, then applying <code>f<\/code> to that result and the 2nd item, etc.<\/p>\n<p>If <code>coll<\/code> contains no items, returns <code>val<\/code> and <code>f<\/code> is not called.<\/p>"
  },
  "cljs.core\/seq": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/seq?",
      "cljs.core\/empty?",
      "cljs.core\/iterator-seq"
    ],
    "full-name": "cljs.core\/seq",
    "description-html": "<p>Returns a sequence on the collection. If the collection is empty, returns nil.<\/p>\n<p><code>(seq nil)<\/code> returns nil.<\/p>\n<p><code>seq<\/code> also works on strings.<\/p>"
  },
  "cljs.core\/compare-and-set!": {
    "signature": [
      "[a oldval newval]"
    ],
    "related": [
      "cljs.core\/atom",
      "cljs.core\/reset!",
      "cljs.core\/swap!"
    ],
    "full-name": "cljs.core\/compare-and-set!",
    "description-html": "<p>Atomically sets the value of atom <code>a<\/code> to <code>newval<\/code> if and only if the current\nvalue of the atom is identical to <code>oldval<\/code>.<\/p>\n<p>Returns true if set happened, false otherwise.<\/p>"
  },
  "cljs.core\/associative?": {
    "signature": [
      "[coll]"
    ],
    "full-name": "cljs.core\/associative?",
    "description-html": "<p>Returns true if <code>coll<\/code> implements the <code>IAssociative<\/code> protocol, false otherwise.<\/p>\n<p>Maps and vectors are associative.<\/p>"
  },
  "cljs.core\/partition-all": {
    "signature": [
      "[n]",
      "[n coll]",
      "[n step coll]"
    ],
    "related": [
      "cljs.core\/partition",
      "cljs.core\/partition-by"
    ],
    "full-name": "cljs.core\/partition-all",
    "description-html": "<p>Returns a lazy sequence of lists like <code>partition<\/code>, but may include partitions\nwith fewer than <code>n<\/code> items at the end.<\/p>\n<p>Returns a stateful transducer when no collection is provided.<\/p>"
  },
  "cljs.core\/last": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/first",
      "cljs.core\/next",
      "cljs.core\/rest",
      "cljs.core\/butlast",
      "cljs.core\/take-last"
    ],
    "full-name": "cljs.core\/last",
    "description-html": "<p>Returns the last item in <code>coll<\/code> in linear time.<\/p>\n<p><code>peek<\/code> is much faster than <code>last<\/code> for a vector.<\/p>"
  },
  "cljs.core\/rand-int": {
    "signature": [
      "[n]"
    ],
    "related": [
      "cljs.core\/rand"
    ],
    "full-name": "cljs.core\/rand-int",
    "description-html": "<p>Returns a random integer between 0 inclusive and <code>n<\/code> exclusive.<\/p>"
  },
  "cljs.core\/mapv": {
    "signature": [
      "[f coll]",
      "[f c1 c2]",
      "[f c1 c2 c3]",
      "[f c1 c2 c3 & colls]"
    ],
    "related": [
      "cljs.core\/map"
    ],
    "full-name": "cljs.core\/mapv",
    "description-html": "<p>Returns a vector consisting of the result of applying <code>f<\/code> to the set of first\nitems of each coll, followed by applying <code>f<\/code> to the set of second items in each\ncoll, until any one of the colls is exhausted. Any remaining items in other\ncolls are ignored.<\/p>\n<p>Function <code>f<\/code> should accept number-of-colls arguments.<\/p>"
  },
  "cljs.core\/rand": {
    "signature": [
      "[]",
      "[n]"
    ],
    "related": [
      "cljs.core\/rand-int",
      "cljs.core\/rand-nth"
    ],
    "full-name": "cljs.core\/rand",
    "description-html": "<p>Returns a random floating point number between 0 inclusive and <code>n<\/code> exclusive.<\/p>\n<p><code>n<\/code> defaults to 1.<\/p>"
  },
  "cljs.core\/take": {
    "signature": [
      "[n]",
      "[n coll]"
    ],
    "related": [
      "cljs.core\/drop",
      "cljs.core\/take-while",
      "cljs.core\/take-last",
      "cljs.core\/take-nth"
    ],
    "full-name": "cljs.core\/take",
    "description-html": "<p>Returns a lazy sequence of the first <code>n<\/code> items in <code>coll<\/code>. Returns all the items\nif there are fewer than <code>n<\/code>.<\/p>\n<p>Returns a stateful transducer when no collection is provided.<\/p>"
  },
  "cljs.core\/aclone": {
    "signature": [
      "[arr]"
    ],
    "related": [
      "cljs.core\/array",
      "cljs.core\/make-array"
    ],
    "full-name": "cljs.core\/aclone",
    "description-html": "<p>Creates a JavaScript array which is a clone of <code>arr<\/code>.<\/p>"
  },
  "cljs.core\/group-by": {
    "signature": [
      "[f coll]"
    ],
    "related": [
      "cljs.core\/partition-by",
      "cljs.core\/frequencies"
    ],
    "full-name": "cljs.core\/group-by",
    "description-html": "<p>Returns a map of the elements of <code>coll<\/code> keyed by the result of running <code>f<\/code> on\neach element.<\/p>\n<p>The value at each key will be a vector of the corresponding elements in the\norder they appeared in <code>coll<\/code>.<\/p>"
  },
  "cljs.core\/atom": {
    "signature": [
      "[x]",
      "[x opts]"
    ],
    "related": [
      "cljs.core\/swap!",
      "cljs.core\/reset!",
      "cljs.core\/set-validator!",
      "cljs.core\/get-validator"
    ],
    "full-name": "cljs.core\/atom",
    "description-html": "<p>Creates and returns an atom with an initial value of <code>x<\/code>.<\/p>\n<p><code>opts<\/code> is an optional map with optional keys <code>:meta<\/code> and <code>:validator<\/code>.<\/p>\n<p><code>:meta<\/code> should be a <a href=\"http:\/\/clojure.org\/metadata\">metadata-map<\/a> for the atom.<\/p>\n<p><code>:validator<\/code> should be a validator function for the atom. See <code>set-validator!<\/code>\nfor more information.<\/p>"
  },
  "cljs.core\/as->": {
    "type": "macro",
    "signature": [
      "[expr name & forms]"
    ],
    "related": [
      "cljs.core\/->",
      "cljs.core\/->>",
      "cljs.core\/cond->",
      "cljs.core\/cond->>",
      "cljs.core\/some->",
      "cljs.core\/some->>"
    ],
    "todo": "add threading macro animations link here",
    "full-name": "cljs.core\/as->",
    "description-html": "<p>Binds <code>name<\/code> to <code>expr<\/code>, evaluates the first form in the lexical context of that\nbinding, then binds <code>name<\/code> to that result, repeating for each successive form,\nreturning the result of the last form.<\/p>\n<p>Useful for when you want a threading macro to use different &quot;places&quot; at each\nform.<\/p>"
  },
  "cljs.core\/not=": {
    "signature": [
      "[x]",
      "[x y]",
      "[x y & more]"
    ],
    "related": [
      "cljs.core\/=",
      "cljs.core\/not"
    ],
    "full-name": "cljs.core\/not=",
    "description-html": "<p>Returns the opposite of <code>=<\/code>.<\/p>\n<p>Same as <code>(not (= x y))<\/code><\/p>"
  },
  "cljs.core\/iterate": {
    "signature": [
      "[f x]"
    ],
    "related": [
      "cljs.core\/cycle",
      "cljs.core\/repeatedly",
      "cljs.core\/repeat"
    ],
    "full-name": "cljs.core\/iterate",
    "description-html": "<p>Returns a lazy sequence of <code>x<\/code>, <code>(f x)<\/code>, <code>(f (f x))<\/code> etc.<\/p>\n<p><code>f<\/code> must be free of side-effects.<\/p>"
  },
  "cljs.core\/string?": {
    "signature": [
      "[x]"
    ],
    "full-name": "cljs.core\/string?",
    "description-html": "<p>Returns true if <code>x<\/code> is a string, false otherwise.<\/p>"
  },
  "cljs.core\/dissoc": {
    "signature": [
      "[coll]",
      "[coll k]",
      "[coll k & ks]"
    ],
    "related": [
      "cljs.core\/assoc",
      "cljs.core\/dissoc-in",
      "cljs.core\/disj",
      "cljs.core\/select-keys"
    ],
    "full-name": "cljs.core\/dissoc",
    "description-html": "<p>dissoc(iate)<\/p>\n<p>Returns a new map that does not contain a mapping for key(s).<\/p>\n<p>Has no effect on the map type (hashed\/sorted).<\/p>"
  },
  "cljs.core\/distinct": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/distinct?"
    ],
    "full-name": "cljs.core\/distinct",
    "description-html": "<p>Returns a lazy sequence of the elements of <code>coll<\/code> with duplicates removed.<\/p>"
  },
  "cljs.core\/quot": {
    "signature": [
      "[n d]"
    ],
    "related": [
      "cljs.core\/rem",
      "cljs.core\/mod"
    ],
    "full-name": "cljs.core\/quot",
    "description-html": "<p>Returns the quotient of dividing numerator <code>n<\/code> by denominator <code>d<\/code>.<\/p>\n<p>Returns <code>NaN<\/code> when <code>d<\/code> is 0 (divide by 0 error).<\/p>"
  },
  "cljs.core\/when-not": {
    "type": "macro",
    "signature": [
      "[test & body]"
    ],
    "related": [
      "cljs.core\/when",
      "cljs.core\/when-let",
      "cljs.core\/if"
    ],
    "full-name": "cljs.core\/when-not",
    "description-html": "<p>Evaluates <code>test<\/code>. If logical false, evaluates <code>body<\/code> in an implicit <code>do<\/code>.<\/p>"
  },
  "cljs.core\/pop": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/peek",
      "cljs.core\/rest",
      "cljs.core\/conj"
    ],
    "full-name": "cljs.core\/pop",
    "description-html": "<p>For a list, returns a new list without the first item.<\/p>\n<p>For a vector, returns a new vector without the last item.<\/p>"
  },
  "cljs.core\/take-nth": {
    "signature": [
      "[n]",
      "[n coll]"
    ],
    "full-name": "cljs.core\/take-nth",
    "description-html": "<p>Returns a lazy seq of every <code>n<\/code>th item in <code>coll<\/code>.<\/p>\n<p>Returns a stateful transducer when no collection is provided.<\/p>"
  },
  "cljs.core\/ns": {
    "type": "special form",
    "signature": [
      "[name & references]"
    ],
    "todo": "we need to write a comprehensive namespace tutorial and link to it here",
    "full-name": "cljs.core\/ns",
    "description-html": "<p>Sets the namespace of the file.<\/p>\n<p><code>ns<\/code> must be the first form in a <code>.cljs<\/code> file and there can only be one <code>ns<\/code>\ndeclaration per file. Namespaces must match the file name of their respective\n<code>.cljs<\/code> files, with the exception that dashes in namespaces become underscores\nin filenames. Thus, <code>(ns foo.bar-biz.baz)<\/code> should be the first form in file\n<code>foo\/bar_biz\/baz.cljs<\/code>.<\/p>\n<p><code>references<\/code> can be zero or more forms used to import other namespaces, symbols,\nand libraries into the current namespace.<\/p>"
  },
  "cljs.core\/try": {
    "type": "special form",
    "signature": [
      "[expr* catch-clause* finally-clause?]"
    ],
    "related": [
      "cljs.core\/catch",
      "cljs.core\/finally",
      "cljs.core\/throw"
    ],
    "full-name": "cljs.core\/try",
    "description-html": "<p>The expressions (<code>expr*<\/code>) are evaluated and, if no exceptions occur, the value\nof the last is returned.<\/p>\n<p>If an exception occurs and catch clauses (<code>catch-clause*<\/code>) are provided, each is\nexamined in turn and the first for which the thrown exception is an instance of\nthe named class is considered a matching catch clause. If there is a matching\ncatch clause, its expressions are evaluated in a context in which name is bound\nto the thrown exception, and the value of the last is the return value of the\nfunction.<\/p>\n<p>If there is no matching catch clause, the exception propagates out of the\nfunction. Before returning, normally or abnormally, any <code>finally-clause?<\/code>\nexpressions will be evaluated for their side effects.<\/p>\n<p><code>try<\/code> is one of ClojureScript&#39;s <a href=\"http:\/\/clojure.org\/special_forms\">special forms<\/a>.<\/p>"
  },
  "clojure.string\/split-lines": {
    "signature": [
      "[s]"
    ],
    "related": [
      "clojure.string\/split"
    ],
    "full-name": "clojure.string\/split-lines",
    "description-html": "<p>Splits <code>s<\/code> on <code>\\n<\/code> or <code>\\r\\n<\/code>.<\/p>"
  },
  "cljs.core\/concat": {
    "signature": [
      "[]",
      "[x]",
      "[x y]",
      "[x y & zs]"
    ],
    "related": [
      "cljs.core\/conj",
      "cljs.core\/into"
    ],
    "full-name": "cljs.core\/concat",
    "description-html": "<p>Returns a lazy sequence representing the concatenation of the elements in the\nsupplied collections.<\/p>"
  },
  "cljs.core\/js->clj": {
    "signature": [
      "[x]",
      "[x & opts]"
    ],
    "related": [
      "cljs.core\/clj->js"
    ],
    "full-name": "cljs.core\/js->clj",
    "description-html": "<p>Recursively transforms JavaScript arrays into ClojureScript vectors, and\nJavaScript objects into ClojureScript maps.<\/p>\n<p>Pass options <code>:keywordize-keys true<\/code> to convert object fields from strings to\nkeywords. ie: <code>(js->clj my-js-data :keywordize-keys true)<\/code><\/p>\n<p>Note that <code>js-&gt;clj<\/code> is not optimized for speed and the <a href=\"http:\/\/swannodette.github.io\/2014\/07\/26\/transit--clojurescript\/\">transit.cljs<\/a> library is\nrecommended for parsing large amounts of JSON data.<\/p>"
  },
  "cljs.core\/if": {
    "type": "special form",
    "signature": [
      "[test then else?]"
    ],
    "related": [
      "cljs.core\/cond",
      "cljs.core\/when",
      "cljs.core\/if-let",
      "cljs.core\/if-not"
    ],
    "full-name": "cljs.core\/if",
    "description-html": "<p>If <code>test<\/code> is not false or nil, <code>then<\/code> is evaluated and returned. Otherwise,\n<code>else?<\/code> is evaluated and returned. <code>else?<\/code> defaults to nil if not provided.<\/p>\n<p><code>if<\/code> is one of ClojureScript&#39;s <a href=\"http:\/\/clojure.org\/special_forms\">special forms<\/a>\nand is a fundamental building block of the language. All other conditionals in\nClojureScript are based on <code>if<\/code>s notion of truthiness (ie: anything other than\nfalse or nil).<\/p>"
  },
  "cljs.core\/max-key": {
    "signature": [
      "[k x]",
      "[k x y]",
      "[k x y & more]"
    ],
    "related": [
      "cljs.core\/max",
      "cljs.core\/min-key"
    ],
    "full-name": "cljs.core\/max-key",
    "description-html": "<p>Returns the <code>x<\/code> for which <code>(k x)<\/code> is greatest.<\/p>\n<p><code>(k x)<\/code> should return a number.<\/p>"
  },
  "cljs.core\/tree-seq": {
    "signature": [
      "[branch? children root]"
    ],
    "full-name": "cljs.core\/tree-seq",
    "description-html": "<p>Returns a lazy sequence of the nodes in a tree, via a depth-first walk.<\/p>\n<p><code>branch?<\/code> must be a function of one argument that returns true if passed a node\nthat can have children (but may not).<\/p>\n<p><code>children<\/code> must be a function of one argument that returns a sequence of the\nchildren. <code>children<\/code> will only be called on nodes for which <code>branch?<\/code> returns\ntrue.<\/p>\n<p><code>root<\/code> is the root node of the tree.<\/p>"
  },
  "cljs.core\/defn-": {
    "type": "macro",
    "signature": [
      "[name & decls]"
    ],
    "related": [
      "cljs.core\/defn"
    ],
    "full-name": "cljs.core\/defn-",
    "description-html": "<p>Same as <code>defn<\/code>, but adds <code>{:private true}<\/code> metadata to the definition.<\/p>\n<p>Note: <code>:private<\/code> metadata is not currently enforced by the ClojureScript\ncompiler.<\/p>"
  },
  "cljs.core\/set-validator!": {
    "signature": [
      "[a fn]"
    ],
    "related": [
      "cljs.core\/atom",
      "cljs.core\/get-validator"
    ],
    "full-name": "cljs.core\/set-validator!",
    "description-html": "<p>Sets a validator function for atom <code>a<\/code>.<\/p>\n<p><code>fn<\/code> must be nil or a side-effect-free function of one argument, which will be\npassed the intended new state on any state change. <code>fn<\/code> should return false or\nthrow an Error if the new state is unacceptable.<\/p>\n<p>If the current value of <code>a<\/code> is unacceptable to <code>fn<\/code> when <code>set-validator!<\/code> is\ncalled, an Error will be thrown and the validator will not be set.<\/p>\n<p><code>(set-validator! my-atom nil)<\/code> will remove the validator from <code>my-atom<\/code>.<\/p>"
  },
  "cljs.core\/defn": {
    "type": "macro",
    "signature": [
      "[name doc-string? attr-map? [params*] prepost-map? body]",
      "[name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]"
    ],
    "related": [
      "cljs.core\/def",
      "cljs.core\/defn-",
      "cljs.core\/defmacro",
      "cljs.core\/fn"
    ],
    "full-name": "cljs.core\/defn",
    "description-html": "<p>Defines a function.<\/p>\n<p><code>doc-string?<\/code> is an optional documentation string.<\/p>\n<p><code>attr-map?<\/code> is an optional map of <a href=\"http:\/\/clojure.org\/metadata\">metadata<\/a> to\nattach to the global variable name.<\/p>\n<p><code>prepost-map?<\/code> is an optional map with optional keys <code>:pre<\/code> and <code>:post<\/code> that\ncontain collections of <a href=\"http:\/\/blog.fogus.me\/2009\/12\/21\/clojures-pre-and-post\/\">pre or post conditions<\/a>\nfor the function.<\/p>\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code<\/th>\n      <th>Expands To<\/th><\/tr><\/thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(defn foo [a b c]\n  (* a b c))<\/pre><\/td>\n      <td><pre>\n(def foo\n  (fn [a b c]\n    (* a b c)))<\/pre><\/td><\/tr><\/tbody><\/table>"
  },
  "cljs.core\/find": {
    "signature": [
      "[coll k]"
    ],
    "related": [
      "cljs.core\/get",
      "cljs.core\/get-in"
    ],
    "full-name": "cljs.core\/find",
    "description-html": "<p>Returns the map entry for key <code>k<\/code>, or nil if <code>k<\/code> is not found.<\/p>"
  },
  "cljs.core\/empty?": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/seq"
    ],
    "full-name": "cljs.core\/empty?",
    "description-html": "<p>Returns true if <code>coll<\/code> has no items - same as <code>(not (seq coll))<\/code>.<\/p>\n<p>Please use the idiom <code>(seq x)<\/code> rather than <code>(not (empty? x))<\/code>.<\/p>"
  },
  "cljs.core\/memoize": {
    "signature": [
      "[f]"
    ],
    "full-name": "cljs.core\/memoize",
    "description-html": "<p>Returns a memoized version of a referentially transparent function.<\/p>\n<p>A memoized version of a function keeps a cache of the mappings from arguments to\nresults in memory. When calls with the same arguments are repeated often, a\nmemoized function has higher performance at the expense of higher memory usage.<\/p>"
  },
  "cljs.core\/bit-test": {
    "signature": [
      "[x n]"
    ],
    "full-name": "cljs.core\/bit-test",
    "description-html": "<p>Test bit at index <code>n<\/code><\/p>"
  },
  "cljs.core\/set": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/hash-set",
      "cljs.core\/sorted-set",
      "cljs.core\/conj",
      "cljs.core\/disj",
      "cljs.core\/distinct",
      "clojure.set\/join",
      "clojure.set\/select",
      "clojure.set\/difference",
      "clojure.set\/intersection",
      "clojure.set\/union",
      "clojure.set\/index",
      "clojure.set\/project",
      "clojure.set\/rename",
      "clojure.set\/rename-keys",
      "clojure.set\/map-invert"
    ],
    "full-name": "cljs.core\/set",
    "description-html": "<p>Returns a set of the distinct elements of <code>coll<\/code>.<\/p>"
  },
  "cljs.core\/bit-set": {
    "signature": [
      "[x n]"
    ],
    "related": [
      "cljs.core\/bit-clear"
    ],
    "full-name": "cljs.core\/bit-set",
    "description-html": "<p>Set bit at index <code>n<\/code><\/p>"
  },
  "cljs.core\/cycle": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/lazy-seq",
      "cljs.core\/repeatedly"
    ],
    "full-name": "cljs.core\/cycle",
    "description-html": "<p>Returns an infinite lazy sequence of repetitions of the items in <code>coll<\/code>.<\/p>"
  },
  "cljs.core\/bit-xor": {
    "signature": [
      "[x y]"
    ],
    "related": [
      "cljs.core\/bit-and",
      "cljs.core\/bit-or"
    ],
    "full-name": "cljs.core\/bit-xor",
    "description-html": "<p>Bitwise exclusive or<\/p>"
  },
  "cljs.core\/unsigned-bit-shift-right": {
    "signature": [
      "[x n]"
    ],
    "related": [
      "cljs.core\/bit-shift-right"
    ],
    "full-name": "cljs.core\/unsigned-bit-shift-right",
    "description-html": "<p>Bitwise shift right with zero fill<\/p>"
  },
  "cljs.core\/into": {
    "signature": [
      "[to from]",
      "[to xform from]"
    ],
    "related": [
      "cljs.core\/conj"
    ],
    "full-name": "cljs.core\/into",
    "description-html": "<p>Returns a new collection consisting of <code>to<\/code> with all of the items of <code>from<\/code>\n&quot;added&quot; using <code>conj<\/code>.<\/p>\n<p>A transducer may be supplied as <code>xform<\/code>.<\/p>"
  },
  "cljs.core\/reset!": {
    "signature": [
      "[a new-value]"
    ],
    "related": [
      "cljs.core\/swap!",
      "cljs.core\/compare-and-set!",
      "cljs.core\/atom"
    ],
    "full-name": "cljs.core\/reset!",
    "description-html": "<p>Sets the value of atom <code>a<\/code> to <code>new-value<\/code> without regard for the current value.<\/p>\n<p>Returns <code>new-value<\/code>.<\/p>"
  },
  "cljs.core\/cond->>": {
    "type": "macro",
    "signature": [
      "[expr & clauses]"
    ],
    "related": [
      "cljs.core\/->",
      "cljs.core\/->>",
      "cljs.core\/cond->",
      "cljs.core\/cond"
    ],
    "full-name": "cljs.core\/cond->>",
    "description-html": "<p>Takes an expression and a set of test\/form pairs. Threads <code>expr<\/code> (via <code>-&gt;&gt;<\/code>)\nthrough each form for which the corresponding test expression is true.<\/p>\n<p>Note that, unlike <code>cond<\/code> branching, <code>cond-&gt;&gt;<\/code> threading does not short circuit\nafter the first true test expression.<\/p>"
  },
  "cljs.core\/map?": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/hash-map",
      "cljs.core\/sorted-map"
    ],
    "full-name": "cljs.core\/map?",
    "description-html": "<p>Returns true if <code>x<\/code> is a map, false otherwise.<\/p>"
  },
  "cljs.core\/sorted-set": {
    "signature": [
      "[& keys]"
    ],
    "related": [
      "cljs.core\/sorted-set-by",
      "cljs.core\/subseq",
      "cljs.core\/rsubseq",
      "cljs.core\/sorted-map"
    ],
    "full-name": "cljs.core\/sorted-set",
    "description-html": "<p>Returns a new sorted set with supplied <code>keys<\/code>.<\/p>"
  },
  "cljs.core\/when-first": {
    "type": "macro",
    "signature": [
      "[bindings & body]"
    ],
    "todo": "This needs better explanation + examples.",
    "full-name": "cljs.core\/when-first",
    "description-html": "<p>With <code>bindings<\/code> as <code>x<\/code>, <code>xs<\/code>, roughly the same as <code>(when (seq xs) (let [x (first\nxs)] body))<\/code> but <code>xs<\/code> is evaluated only once.<\/p>"
  },
  "cljs.core\/conj": {
    "signature": [
      "[]",
      "[coll]",
      "[coll x]",
      "[coll x & xs]"
    ],
    "related": [
      "cljs.core\/cons",
      "cljs.core\/into",
      "cljs.core\/peek",
      "cljs.core\/pop"
    ],
    "todo": "should add a table here of how things are \"added\" to different collection types",
    "full-name": "cljs.core\/conj",
    "description-html": "<p>conj(oin)<\/p>\n<p>Returns a new collection with the <code>x<\/code>s &quot;added&quot; to <code>coll<\/code>.<\/p>\n<p>The &quot;addition&quot; may happen at different &quot;places&quot; depending on the collection\ntype.<\/p>\n<p><code>(conj nil item)<\/code> returns <code>(item)<\/code>.<\/p>"
  },
  "cljs.core\/fnil": {
    "signature": [
      "[f x]",
      "[f x y]",
      "[f x y z]"
    ],
    "full-name": "cljs.core\/fnil",
    "description-html": "<p>Takes a function <code>f<\/code>, and returns a function that calls <code>f<\/code>, replacing a nil\nfirst argument to <code>f<\/code> with the supplied value <code>x<\/code>. Higher arity versions can\nreplace arguments in the second and third positions (<code>y<\/code>, <code>z<\/code>).<\/p>\n<p>Note that the function <code>f<\/code> can take any number of arguments, not just the one(s)\nbeing nil-patched.<\/p>"
  },
  "cljs.core\/merge-with": {
    "signature": [
      "[f & maps]"
    ],
    "related": [
      "cljs.core\/merge"
    ],
    "full-name": "cljs.core\/merge-with",
    "description-html": "<p>Returns a map that consists of the rest of the maps <code>conj<\/code>-ed onto the first.<\/p>\n<p>If a key occurs in more than one map, the mapping(s) from the latter (left-to-\nright) will be combined with the mapping in the result by calling <code>(f val-in-\nresult val-in-latter)<\/code>.<\/p>"
  },
  "cljs.core\/-": {
    "signature": [
      "[x]",
      "[x y]",
      "[x y & more]"
    ],
    "related": [
      "cljs.core\/+"
    ],
    "full-name": "cljs.core\/-",
    "description-html": "<p>If no <code>y<\/code>s are supplied, returns the negation of <code>x<\/code>, else subtracts the <code>y<\/code>s\nfrom <code>x<\/code> and returns the result.<\/p>"
  },
  "cljs.core\/contains?": {
    "signature": [
      "[coll k]"
    ],
    "related": [
      "cljs.core\/some",
      "cljs.core\/get"
    ],
    "full-name": "cljs.core\/contains?",
    "description-html": "<p>Returns true if <code>k<\/code> is present in <code>coll<\/code>, otherwise returns false.<\/p>\n<p>Note that for numerically indexed collections like vectors and arrays, this\ntests if the numeric key is within the range of indexes.<\/p>\n<p><code>contains?<\/code> operates in constant or logarithmic time; it will not perform a\nlinear search for a value.<\/p>"
  },
  "cljs.core\/identical?": {
    "signature": [
      "[x y]"
    ],
    "return type": "boolean",
    "related": [
      "cljs.core\/=",
      "cljs.core\/=="
    ],
    "full-name": "cljs.core\/identical?",
    "description-html": "<p>Returns true if <code>x<\/code> and <code>y<\/code> are the same object, false otherwise.<\/p>"
  },
  "cljs.core\/rand-nth": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/rand"
    ],
    "full-name": "cljs.core\/rand-nth",
    "description-html": "<p>Returns a random element from a sequential collection <code>coll<\/code>.<\/p>\n<p>Has the same performance characteristics as <code>nth<\/code>.<\/p>"
  },
  "cljs.core\/if-some": {
    "type": "macro",
    "signature": [
      "[[x test] then]",
      "[[x test] then else]"
    ],
    "related": [
      "cljs.core\/when-some"
    ],
    "full-name": "cljs.core\/if-some",
    "description-html": "<p>If <code>test<\/code> is not nil, evaluates <code>then<\/code> with <code>x<\/code> bound to the value of <code>test<\/code>. If\nnot, yields <code>else<\/code>.<\/p>"
  },
  "cljs.core\/re-pattern": {
    "signature": [
      "[s]"
    ],
    "full-name": "cljs.core\/re-pattern",
    "description-html": "<p>Returns an instance of RegExp which has compiled the provided string.<\/p>"
  },
  "cljs.core\/sort": {
    "signature": [
      "[coll]",
      "[comp coll]"
    ],
    "related": [
      "cljs.core\/sort-by"
    ],
    "full-name": "cljs.core\/sort",
    "description-html": "<p>Returns a sorted sequence of the items in <code>coll<\/code>.<\/p>\n<p><code>comp<\/code> can be a boolean-valued comparison funcion, or a -\/0\/+ valued comparator.<\/p>\n<p><code>comp<\/code> defaults to <code>compare<\/code>.<\/p>"
  },
  "cljs.core\/zipmap": {
    "signature": [
      "[keys vals]"
    ],
    "related": [
      "cljs.core\/interleave"
    ],
    "full-name": "cljs.core\/zipmap",
    "description-html": "<p>Returns a map with <code>keys<\/code> mapped to corresponding <code>vals<\/code>.<\/p>\n<pre>user=> (zipmap [:a :b :c :d] [1 2 3 4])\n{:a 1, :b 2, :c 3, :d 4}<\/pre>"
  },
  "cljs.core\/fn?": {
    "signature": [
      "[f]"
    ],
    "related": [
      "cljs.core\/ifn?"
    ],
    "full-name": "cljs.core\/fn?",
    "description-html": "<p>Returns true if <code>f<\/code> is a function, false otherwise.<\/p>"
  },
  "clojure.string\/trim-newline": {
    "signature": [
      "[s]"
    ],
    "full-name": "clojure.string\/trim-newline",
    "description-html": "<p>Removes all trailing newline <code>\\n<\/code> or return <code>\\r<\/code> characters from string.<\/p>\n<p>Similar to Perl&#39;s chomp.<\/p>"
  },
  "cljs.core\/juxt": {
    "signature": [
      "[f]",
      "[f g]",
      "[f g h]",
      "[f g h & fs]"
    ],
    "related": [
      "cljs.core\/partial",
      "cljs.core\/comp"
    ],
    "full-name": "cljs.core\/juxt",
    "description-html": "<p>Takes a set of functions and returns a function that is the juxtaposition of\nthose functions.<\/p>\n<p>The returned function takes a variable number of arguments, and returns a vector\ncontaining the result of applying each function to the arguments (left-to-\nright).<\/p>\n<p><code>((juxt a b c) x)<\/code> =&gt; <code>[(a x) (b x) (c x)]<\/code><\/p>"
  },
  "cljs.core\/peek": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/first",
      "cljs.core\/pop",
      "cljs.core\/conj"
    ],
    "full-name": "cljs.core\/peek",
    "description-html": "<p>Returns the first element of a list; same as <code>first<\/code>.<\/p>\n<p>Returns the last element of a vector, and much more efficient than using <code>last<\/code>.<\/p>\n<p>Returns nil if <code>coll<\/code> is empty.<\/p>"
  },
  "cljs.core\/map": {
    "signature": [
      "[f]",
      "[f coll]",
      "[f c1 c2]",
      "[f c1 c2 c3]",
      "[f c1 c2 c3 & colls]"
    ],
    "related": [
      "cljs.core\/map-indexed",
      "cljs.core\/pmap",
      "cljs.core\/amap",
      "cljs.core\/mapcat",
      "cljs.core\/keep",
      "cljs.core\/juxt"
    ],
    "full-name": "cljs.core\/map",
    "description-html": "<p>Returns a lazy sequence of applying function <code>f<\/code> to every element of <code>coll<\/code>.<\/p>\n<p>When more than one collection is provided, returns a lazy sequence consisting of\nthe result of applying <code>f<\/code> to the set of first items of each <code>c<\/code>, followed by\napplying <code>f<\/code> to the set of second items in each <code>c<\/code>, until any one of the <code>c<\/code>s\nis exhausted. Any remaining items in other <code>c<\/code>s are ignored. Function <code>f<\/code> should\naccept number-of-<code>c<\/code>s arguments.<\/p>\n<p>Returns a transducer when no collection is provided.<\/p>"
  },
  "cljs.core\/js-obj": {
    "signature": [
      "[& keyvals]"
    ],
    "related": [
      "cljs.core\/array"
    ],
    "full-name": "cljs.core\/js-obj",
    "description-html": "<p>Returns a new JavaScript object using the supplied mappings.<\/p>\n<p><code>keyvals<\/code> must be an even number of forms.<\/p>"
  },
  "cljs.core\/get-in": {
    "signature": [
      "[m ks]",
      "[m ks not-found]"
    ],
    "related": [
      "cljs.core\/assoc-in",
      "cljs.core\/update-in",
      "cljs.core\/find",
      "cljs.core\/get"
    ],
    "full-name": "cljs.core\/get-in",
    "description-html": "<p>Returns the value in a nested associative structure, where <code>ks<\/code> is a sequence of\nkeys.<\/p>\n<p>Returns nil if the key is not found, or <code>not-found<\/code> if supplied.<\/p>"
  },
  "cljs.core\/empty": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/not-empty"
    ],
    "full-name": "cljs.core\/empty",
    "description-html": "<p>Returns an empty collection of the same category as <code>coll<\/code>.<\/p>\n<p>Returns nil if <code>coll<\/code> is nil.<\/p>"
  },
  "cljs.core\/sorted-set-by": {
    "signature": [
      "[comparator & keys]"
    ],
    "related": [
      "cljs.core\/sorted-set",
      "cljs.core\/sorted-map-by",
      "cljs.core\/compare"
    ],
    "full-name": "cljs.core\/sorted-set-by",
    "description-html": "<p>Returns a new sorted set with supplied <code>keys<\/code>, using the supplied <code>comparator<\/code>.<\/p>"
  },
  "cljs.core\/letfn": {
    "type": "special form",
    "signature": [
      "[fnspecs & body]"
    ],
    "related": [
      "cljs.core\/let"
    ],
    "full-name": "cljs.core\/letfn",
    "description-html": "<p>Takes a vector of function definitions <code>fnspecs<\/code> and binds the functions to\ntheir names. All of the names are available in all of the definitions of the\nfunctions as well as <code>body<\/code>.<\/p>\n<p><code>fnspecs<\/code> must be a vector with an even number of forms. See <code>let<\/code>.<\/p>\n<p><code>letfn<\/code> is one of ClojureScript&#39;s <a href=\"http:\/\/clojure.org\/special_forms\">special forms<\/a>.<\/p>"
  },
  "cljs.core\/filterv": {
    "signature": [
      "[pred coll]"
    ],
    "full-name": "cljs.core\/filterv",
    "description-html": "<p>Returns a vector of the items in <code>coll<\/code> for which <code>(pred item)<\/code> returns true.<\/p>\n<p><code>pred<\/code> must be free of side-effects.<\/p>"
  },
  "cljs.core\/bit-or": {
    "signature": [
      "[x y]"
    ],
    "related": [
      "cljs.core\/bit-and",
      "cljs.core\/bit-xor"
    ],
    "full-name": "cljs.core\/bit-or",
    "description-html": "<p>Bitwise or<\/p>"
  },
  "cljs.core\/def": {
    "type": "special form",
    "signature": [
      "[symbol]",
      "[symbol init]",
      "[symbol doc-string init]"
    ],
    "related": [
      "cljs.core\/defn",
      "cljs.core\/fn",
      "cljs.core\/defmacro",
      "cljs.core\/defmulti"
    ],
    "todo": "Need to include something about metadata here?",
    "full-name": "cljs.core\/def",
    "description-html": "<p>Creates a global variable with the name of <code>symbol<\/code> and a namespace of the\ncurrent namespace.<\/p>\n<p>If <code>init<\/code> is supplied, it is evaluated and the result is assigned to <code>symbol<\/code>.<\/p>\n<p><code>doc-string<\/code> is an optional documentation string.<\/p>\n<p><code>def<\/code> is one of ClojureScript&#39;s <a href=\"http:\/\/clojure.org\/special_forms\">special forms<\/a>\nand is used by many macros to define common elements (ie: <code>defn<\/code>, <code>defmacro<\/code>,\netc).<\/p>"
  },
  "cljs.core\/nfirst": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/next"
    ],
    "full-name": "cljs.core\/nfirst",
    "description-html": "<p>Same as <code>(next (first coll))<\/code>.<\/p>"
  },
  "cljs.core\/true?": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/false?"
    ],
    "full-name": "cljs.core\/true?",
    "description-html": "<p>Returns true if <code>x<\/code> is the value true, false otherwise.<\/p>"
  },
  "cljs.core\/\/": {
    "signature": [
      "[x]",
      "[x y]",
      "[x y & more]"
    ],
    "related": [
      "cljs.core\/*",
      "cljs.core\/quot"
    ],
    "full-name": "cljs.core\/\/",
    "description-html": "<p>If no denominators are supplied, returns 1\/numerator, else returns numerator\ndivided by all of the denominators.<\/p>"
  },
  "cljs.core\/number?": {
    "signature": [
      "[n]"
    ],
    "related": [
      "cljs.core\/integer?"
    ],
    "full-name": "cljs.core\/number?",
    "description-html": "<p>Returns true if <code>n<\/code> is a number, false otherwise.<\/p>"
  },
  "cljs.core\/get": {
    "signature": [
      "[o k]",
      "[o k not-found]"
    ],
    "related": [
      "cljs.core\/get-in"
    ],
    "full-name": "cljs.core\/get",
    "description-html": "<p>Returns the value mapped to key <code>k<\/code>.<\/p>\n<p>Returns <code>not-found<\/code> or nil if <code>k<\/code> is not present in <code>o<\/code>.<\/p>"
  },
  "cljs.core\/vals": {
    "signature": [
      "[hash-map]"
    ],
    "related": [
      "cljs.core\/keys"
    ],
    "full-name": "cljs.core\/vals",
    "description-html": "<p>Returns a sequence of the values in <code>hash-map<\/code>.<\/p>"
  },
  "cljs.core\/lazy-seq": {
    "signature": [
      "[& body]"
    ],
    "related": [
      "cljs.core\/lazy-cat",
      "cljs.core\/realized?",
      "cljs.core\/doall",
      "cljs.core\/iterate"
    ],
    "full-name": "cljs.core\/lazy-seq",
    "description-html": "<p>Returns a new lazy sequence.<\/p>"
  },
  "cljs.core\/swap!": {
    "signature": [
      "[a f]",
      "[a f x]",
      "[a f x y]",
      "[a f x y & more]"
    ],
    "related": [
      "cljs.core\/atom",
      "cljs.core\/reset!"
    ],
    "full-name": "cljs.core\/swap!",
    "description-html": "<p>Atomically swaps the value of atom to be: <code>(apply f current-value-of-atom\nargs)<\/code><\/p>\n<p>Note that <code>f<\/code> may be called multiple times, and thus should be free of side\neffects.<\/p>\n<p>Returns the value that was swapped in.<\/p>"
  },
  "cljs.core\/let": {
    "type": "special form",
    "signature": [
      "[bindings & body]"
    ],
    "related": [
      "cljs.core\/letfn",
      "cljs.core\/if-let"
    ],
    "full-name": "cljs.core\/let",
    "description-html": "<p>Binds expressions to symbols and makes those symbols available only within\n<code>body<\/code>.<\/p>\n<p><code>bindings<\/code> should be a vector with an even number of forms, ie: <code>[a1 b1, a2 b2,\na3 b3]<\/code>. The first item in a pair (the <code>a<\/code>s) should be a symbol that is assigned\nthe evaluation of the second item (the <code>b<\/code>s). These symbols (the <code>a<\/code>s) are then\navailable within <code>body<\/code> (and not outside of <code>body<\/code>).<\/p>\n<p>Another way to think about this is that the binding symbols in <code>let<\/code> are like\nlocal <code>def<\/code>s that are only available within <code>let<\/code>&#39;s scope.<\/p>\n<p>In addition to direct symbol binding, <code>let<\/code> supports a destructuring syntax to\n&quot;break apart&quot; collections into multiple symbols. This destructuring syntax is\nlike it&#39;s own <a href=\"http:\/\/blog.jayfields.com\/2010\/07\/clojure-destructuring.html\">mini-language<\/a> and allows for succinct code.<\/p>\n<p><code>let<\/code> is one of ClojureScript&#39;s <a href=\"http:\/\/clojure.org\/special_forms\">special forms<\/a> and is a fundamental building\nblock of the language. Many macros rely on <code>let<\/code>s binding syntax and scope\nrules.<\/p>"
  },
  "cljs.core\/nthnext": {
    "signature": [
      "[coll n]"
    ],
    "related": [
      "cljs.core\/nth",
      "cljs.core\/drop",
      "cljs.core\/nthrest"
    ],
    "full-name": "cljs.core\/nthnext",
    "description-html": "<p>Returns the <code>n<\/code>th <code>next<\/code> of <code>coll<\/code>.<\/p>\n<p>Returns <code>(seq coll)<\/code> when <code>n<\/code> is 0.<\/p>"
  },
  "cljs.core\/make-array": {
    "signature": [
      "[size]"
    ],
    "related": [
      "cljs.core\/aclone",
      "cljs.core\/array"
    ],
    "full-name": "cljs.core\/make-array",
    "description-html": "<p>Creates an empty JavaScript array of size <code>size<\/code>.<\/p>"
  },
  "clojure.string\/trimr": {
    "signature": [
      "[s]"
    ],
    "full-name": "clojure.string\/trimr",
    "description-html": "<p>Removes whitespace from the right side of string.<\/p>"
  },
  "cljs.core\/partition-by": {
    "signature": [
      "[f]",
      "[f coll]"
    ],
    "related": [
      "cljs.core\/partition",
      "cljs.core\/partition-all",
      "cljs.core\/group-by"
    ],
    "full-name": "cljs.core\/partition-by",
    "description-html": "<p>Applies <code>f<\/code> to each value in <code>coll<\/code>, splitting it each time <code>f<\/code> returns a new\nvalue. Returns a lazy sequence of partitions.<\/p>\n<p>Returns a stateful transducer when no collection is provided.<\/p>"
  },
  "cljs.core\/remove": {
    "signature": [
      "[pred]",
      "[pred coll]"
    ],
    "related": [
      "cljs.core\/filter"
    ],
    "full-name": "cljs.core\/remove",
    "description-html": "<p>Returns a lazy sequence of the items in <code>coll<\/code> for which <code>(pred item)<\/code> returns\nfalse.<\/p>\n<p><code>pred<\/code> must be free of side-effects.<\/p>\n<p>Returns a transducer when no collection is provided.<\/p>"
  },
  "cljs.core\/subseq": {
    "signature": [
      "[sc test key]",
      "[sc start-test start-key end-test end-key]"
    ],
    "related": [
      "cljs.core\/rsubseq",
      "cljs.core\/sorted-map",
      "cljs.core\/sorted-set",
      "cljs.core\/sorted-map-by",
      "cljs.core\/sorted-set-by"
    ],
    "full-name": "cljs.core\/subseq",
    "description-html": "<p><code>sc<\/code> must be a sorted collection.<\/p>\n<p><code>test<\/code>, <code>start-test<\/code>, <code>end-test<\/code> must be <code>&lt;<\/code>, <code>&lt;=<\/code>, <code>&gt;<\/code> or <code>&gt;=<\/code>.<\/p>\n<p>Returns a sequence of those entries with keys <code>ek<\/code> for which\n<code>(test (.. sc comparator (compare ek key)) 0)<\/code> is true.<\/p>"
  },
  "cljs.core\/condp": {
    "type": "macro",
    "signature": [
      "[pred expr & clauses]"
    ],
    "related": [
      "cljs.core\/cond",
      "cljs.core\/if"
    ],
    "full-name": "cljs.core\/condp",
    "description-html": "<p>Takes a binary predicate, an expression, and a set of clauses. There are two\nkinds of clauses:<\/p>\n<p>Binary clause: <code>test-expr<\/code> <code>result-expr<\/code><\/p>\n<p>Ternary clause: <code>test-expr<\/code> <code>:&gt;&gt;<\/code> <code>result-fn<\/code><br \/>\n(Note: <code>:&gt;&gt;<\/code> is an ordinary keyword)<\/p>\n<p>For each clause, <code>(pred test-expr expr)<\/code> is evaluated. If it returns logical\ntrue, the clause is a match.<\/p>\n<p>If a binary clause matches, its <code>result-expr<\/code> is returned.<\/p>\n<p>If a ternary clause matches, its <code>result-fn<\/code> is called with the result of the\npredicate and returned by <code>condp<\/code>. <code>result-fn<\/code> should take one argument.<\/p>\n<p>A single default expression can follow the clauses, and its value will be\nreturned if no clause matches.<\/p>\n<p>If no default expression is provided and no clause matches, an Error is thrown.<\/p>"
  },
  "cljs.core\/cond": {
    "type": "macro",
    "signature": [
      "[& clauses]"
    ],
    "related": [
      "cljs.core\/condp",
      "cljs.core\/case",
      "cljs.core\/if"
    ],
    "full-name": "cljs.core\/cond",
    "description-html": "<p><code>clauses<\/code> must be an even number of forms, ie: <code>(cond t1 e1, t2 e2, t3 e3)<\/code>.\nEach test <code>t<\/code> is evaluated one at a time. If a test returns logical true, <code>cond<\/code>\nevaluates and returns the corresponding expression <code>e<\/code> and does not evaluate any\nof the other tests or expressions.<\/p>\n<p>It is idiomatic to provide a default case as the last test pair using the\nkeyword <code>:else<\/code> (a keyword always evaluates to logical true).<\/p>\n<p><code>(cond)<\/code> returns nil.<\/p>"
  },
  "cljs.core\/constantly": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/repeatedly"
    ],
    "full-name": "cljs.core\/constantly",
    "description-html": "<p>Returns a function that takes any number of arguments and always returns <code>x<\/code>.<\/p>"
  },
  "cljs.core\/integer?": {
    "signature": [
      "[n]"
    ],
    "related": [
      "cljs.core\/int"
    ],
    "full-name": "cljs.core\/integer?",
    "description-html": "<p>Returns true if <code>n<\/code> is an integer, false otherwise.<\/p>"
  },
  "cljs.core\/flatten": {
    "signature": [
      "[x]"
    ],
    "full-name": "cljs.core\/flatten",
    "description-html": "<p>Takes any nested combination of sequential things (lists, vectors, etc.) and\nreturns their contents as a single, flat sequence.<\/p>\n<p><code>(flatten nil)<\/code> returns nil.<\/p>"
  },
  "cljs.core\/clj->js": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/js->clj"
    ],
    "full-name": "cljs.core\/clj->js",
    "description-html": "<p>Recursively transforms ClojureScript values to JavaScript.<\/p>\n<table>\n<thead>\n<tr>\n<th>ClojureScript<\/th>\n<th><\/th>\n<th>JavaScript<\/th>\n<th><\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>Set<\/td>\n<td><code>#{}<\/code><\/td>\n<td>Array<\/td>\n<td><code>[]<\/code><\/td>\n<\/tr>\n<tr>\n<td>Vector<\/td>\n<td><code>[]<\/code><\/td>\n<td>Array<\/td>\n<td><code>[]<\/code><\/td>\n<\/tr>\n<tr>\n<td>List<\/td>\n<td><code>()<\/code><\/td>\n<td>Array<\/td>\n<td><code>[]<\/code><\/td>\n<\/tr>\n<tr>\n<td>Keyword<\/td>\n<td><code>:foo<\/code><\/td>\n<td>String<\/td>\n<td><code>&quot;foo&quot;<\/code><\/td>\n<\/tr>\n<tr>\n<td>Symbol<\/td>\n<td><code>bar<\/code><\/td>\n<td>String<\/td>\n<td><code>&quot;bar&quot;<\/code><\/td>\n<\/tr>\n<tr>\n<td>Map<\/td>\n<td><code>{}<\/code><\/td>\n<td>Object<\/td>\n<td><code>{}<\/code><\/td>\n<\/tr>\n<\/tbody>\n<\/table>"
  },
  "cljs.core\/when-let": {
    "type": "macro",
    "signature": [
      "[[x test] & body]"
    ],
    "related": [
      "cljs.core\/if-let",
      "cljs.core\/when",
      "cljs.core\/when-not",
      "cljs.core\/if",
      "cljs.core\/when-first"
    ],
    "full-name": "cljs.core\/when-let",
    "description-html": "<p>When <code>test<\/code> is logical true, evaluates <code>body<\/code> with the value of <code>test<\/code> bound to\n<code>x<\/code>.<\/p>"
  },
  "clojure.set\/difference": {
    "signature": [
      "[s1]",
      "[s1 s2]",
      "[s1 s2 & sets]"
    ],
    "related": [
      "clojure.set\/union",
      "clojure.set\/intersection",
      "clojure.set\/superset?",
      "clojure.set\/project"
    ],
    "full-name": "clojure.set\/difference",
    "description-html": "<p>Return a set that is the first set without elements of the remaining sets.<\/p>"
  },
  "cljs.core\/partition": {
    "signature": [
      "[n coll]",
      "[n step coll]",
      "[n step pad coll]"
    ],
    "related": [
      "cljs.core\/partition-all",
      "cljs.core\/split-at",
      "cljs.core\/partition-by"
    ],
    "todo": "This function really needs an example.",
    "full-name": "cljs.core\/partition",
    "description-html": "<p>Returns a lazy sequence of lists of <code>n<\/code> items each, at offsets <code>step<\/code> apart.<\/p>\n<p>If <code>step<\/code> is not supplied, defaults to <code>n<\/code>, i.e. the partitions do not overlap.<\/p>\n<p>If a <code>pad<\/code> collection is supplied, its elements will be used as necessary to\ncomplete the last partition up to <code>n<\/code> items.<\/p>\n<p>Returns a partition with less than <code>n<\/code> items if there are not enough padding\nelements.<\/p>"
  },
  "cljs.core\/drop-last": {
    "signature": [
      "[s]",
      "[n s]"
    ],
    "related": [
      "cljs.core\/drop",
      "cljs.core\/drop-while"
    ],
    "full-name": "cljs.core\/drop-last",
    "description-html": "<p>Return a lazy sequence of all but the last <code>n<\/code> items in <code>s<\/code>.<\/p>\n<p><code>n<\/code> defaults to 1.<\/p>"
  },
  "cljs.core\/object?": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/array?"
    ],
    "full-name": "cljs.core\/object?",
    "description-html": "<p>Returns true if <code>x<\/code> is a JavaScript object, false otherwise.<\/p>"
  },
  "cljs.core\/not-empty": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/empty"
    ],
    "full-name": "cljs.core\/not-empty",
    "description-html": "<p>Returns nil if <code>coll<\/code> is empty, else returns <code>coll<\/code>.<\/p>"
  },
  "cljs.core\/*": {
    "signature": [
      "[]",
      "[x]",
      "[x y]",
      "[x y & more]"
    ],
    "related": [
      "cljs.core\/+",
      "cljs.core\/\/"
    ],
    "full-name": "cljs.core\/*",
    "description-html": "<p>Returns the product of nums.<\/p>\n<p><code>(*)<\/code> returns 1.<\/p>"
  },
  "cljs.core\/min": {
    "signature": [
      "[x]",
      "[x y]",
      "[x y & more]"
    ],
    "related": [
      "cljs.core\/max",
      "cljs.core\/min-key"
    ],
    "full-name": "cljs.core\/min",
    "description-html": "<p>Returns the least number argument.<\/p>"
  },
  "cljs.core\/re-find": {
    "signature": [
      "[re s]"
    ],
    "full-name": "cljs.core\/re-find",
    "description-html": "<p>Returns the first regex match, if any, of <code>s<\/code> to <code>re<\/code>, using <code>re.exec(s)<\/code>.<\/p>\n<p>Returns a vector, containing first the matching substring, then any capturing\ngroups if the regular expression contains capturing groups.<\/p>"
  },
  "clojure.set\/superset?": {
    "signature": [
      "[a b]"
    ],
    "related": [
      "cljs.core\/set",
      "cljs.core\/set?",
      "clojure.set\/subset?"
    ],
    "full-name": "clojure.set\/superset?",
    "description-html": "<p>Returns true if <code>a<\/code> is a superset of <code>b<\/code>, false otherwise.<\/p>\n<p>In other words, returns true if <code>a<\/code> contains all the elements of <code>b<\/code>.<\/p>"
  },
  "cljs.core\/<=": {
    "signature": [
      "[x]",
      "[x y]",
      "[x y & more]"
    ],
    "related": [
      "cljs.core\/<"
    ],
    "full-name": "cljs.core\/<=",
    "description-html": "<p>Returns true if each successive number argument is greater than or equal to the\nprevious one, false otherwise.<\/p>"
  },
  "cljs.core\/declare": {
    "type": "macro",
    "signature": [
      "[& names]"
    ],
    "related": [
      "cljs.core\/def"
    ],
    "full-name": "cljs.core\/declare",
    "description-html": "<p>Uses <code>def<\/code> to establish symbols of <code>names<\/code> with no bindings.<\/p>\n<p>Useful for making forward declarations.<\/p>"
  },
  "cljs.core\/cond->": {
    "type": "macro",
    "signature": [
      "[expr & clauses]"
    ],
    "related": [
      "cljs.core\/->",
      "cljs.core\/->>",
      "cljs.core\/cond->>",
      "cljs.core\/cond"
    ],
    "full-name": "cljs.core\/cond->",
    "description-html": "<p>Takes an expression and a set of test\/form pairs. Threads <code>expr<\/code> (via <code>-&gt;<\/code>)\nthrough each form for which the corresponding test expression is true.<\/p>\n<p>Note that, unlike <code>cond<\/code> branching, <code>cond-&gt;<\/code> threading does not short circuit\nafter the first true test expression.<\/p>"
  },
  "cljs.core\/to-array-2d": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/to-array"
    ],
    "todo": "This needs an example.",
    "full-name": "cljs.core\/to-array-2d",
    "description-html": "<p>Returns a (potentially-ragged) 2-dimensional JavaScript array containing the\ncontents of <code>coll<\/code>.<\/p>"
  },
  "cljs.core\/distinct?": {
    "signature": [
      "[x]",
      "[x y]",
      "[x y & more]"
    ],
    "related": [
      "cljs.core\/distinct"
    ],
    "full-name": "cljs.core\/distinct?",
    "description-html": "<p>Returns true if no two of the arguments are <code>=<\/code><\/p>"
  },
  "cljs.core\/mod": {
    "signature": [
      "[n d]"
    ],
    "related": [
      "cljs.core\/rem"
    ],
    "full-name": "cljs.core\/mod",
    "description-html": "<p>Returns the modulus of dividing numerator <code>n<\/code> by denominator <code>d<\/code>.<\/p>\n<p>Returns <code>NaN<\/code> when <code>d<\/code> is 0 (divide by 0 error).<\/p>\n<p>Truncates toward negative infinity.<\/p>"
  },
  "cljs.core\/frequencies": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/group-by",
      "cljs.core\/distinct"
    ],
    "full-name": "cljs.core\/frequencies",
    "description-html": "<p>Returns a map from distinct items in <code>coll<\/code> to the number of times they appear.<\/p>\n<p><code>(frequencies [:a :a :b])<\/code> =&gt; <code>{:a 2, :b 1}<\/code><\/p>"
  },
  "cljs.core\/set?": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/set"
    ],
    "full-name": "cljs.core\/set?",
    "description-html": "<p>Returns true if <code>x<\/code> is a set, false otherwise.<\/p>"
  },
  "cljs.core\/for": {
    "type": "macro",
    "signature": [
      "[seq-exprs body-expr]"
    ],
    "related": [
      "cljs.core\/doseq",
      "cljs.core\/doall",
      "cljs.core\/recur"
    ],
    "todo": "This description is completely unreadable to someone new to the\nlanguage and confusing even to someone with moderate experience (ie: me)\n\nNeed to simplify and provide an inline example.",
    "full-name": "cljs.core\/for",
    "description-html": "<p>List comprehension.<\/p>\n<p>Takes a vector of one or more binding-form\/collection-expr pairs, each followed\nby zero or more modifiers, and yields a lazy sequence of evaluations of expr.<\/p>\n<p>Collections are iterated in a nested fashion, rightmost fastest, and nested\ncoll-exprs can refer to bindings created in prior binding-forms. Supported\nmodifiers are: <code>:let [binding-form expr ...]<\/code>, <code>:while test<\/code>, <code>:when test<\/code>.<\/p>"
  },
  "cljs.core\/nil?": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/true?",
      "cljs.core\/false?",
      "cljs.core\/identity"
    ],
    "full-name": "cljs.core\/nil?",
    "description-html": "<p>Returns true if <code>x<\/code> is nil, false otherwise.<\/p>"
  },
  "cljs.core\/sorted?": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/sorted-map",
      "cljs.core\/sorted-set"
    ],
    "full-name": "cljs.core\/sorted?",
    "description-html": "<p>Returns true if <code>coll<\/code> implements the <code>ISorted<\/code> protocol, false otherwise.<\/p>\n<p>Sorted maps and sorted sets implement <code>ISorted<\/code>.<\/p>"
  },
  "cljs.core\/nth": {
    "signature": [
      "[coll n]",
      "[coll n not-found]"
    ],
    "related": [
      "cljs.core\/first",
      "cljs.core\/second",
      "cljs.core\/nthnext",
      "cljs.core\/get"
    ],
    "full-name": "cljs.core\/nth",
    "description-html": "<p>Returns the value at index <code>n<\/code> or <code>not-found<\/code> if the index is out of bounds.<\/p>\n<p><code>nth<\/code> will throw an exception if <code>n<\/code> is out of bounds and <code>not-found<\/code> is not\nsupplied.<\/p>\n<p><code>nth<\/code> works for Strings, Arrays, Regex Matchers, Lists, and Sequences. For\nSequences, <code>nth<\/code> takes O(n) time.<\/p>"
  },
  "cljs.core\/split-at": {
    "signature": [
      "[n coll]"
    ],
    "related": [
      "cljs.core\/split-with",
      "clojure.string\/split"
    ],
    "full-name": "cljs.core\/split-at",
    "description-html": "<p>Returns a vector of <code>[(take n coll) (drop n coll)]<\/code>.<\/p>"
  },
  "cljs.core\/rseq": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/reverse"
    ],
    "full-name": "cljs.core\/rseq",
    "description-html": "<p>Returns a sequence of the items in <code>coll<\/code> in reverse order in constant time.<\/p>\n<p>Returns nil if <code>coll<\/code> is empty.<\/p>\n<p><code>coll<\/code> must be a vector or a sorted-map.<\/p>"
  },
  "cljs.core\/not-every?": {
    "signature": [
      "[pred coll]"
    ],
    "related": [
      "cljs.core\/every?",
      "cljs.core\/not-any?",
      "cljs.core\/some"
    ],
    "full-name": "cljs.core\/not-every?",
    "description-html": "<p>Returns false if <code>(pred x)<\/code> is logical true for every <code>x<\/code> in <code>coll<\/code>, else true.<\/p>"
  },
  "cljs.core\/nnext": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/next"
    ],
    "full-name": "cljs.core\/nnext",
    "description-html": "<p>Same as <code>(next (next coll))<\/code>.<\/p>"
  },
  "cljs.core\/subvec": {
    "signature": [
      "[v start]",
      "[v start end]"
    ],
    "related": [
      "cljs.core\/vector",
      "cljs.core\/vector?"
    ],
    "full-name": "cljs.core\/subvec",
    "description-html": "<p>Returns a persistent vector of the items in <code>v<\/code> from <code>start<\/code> inclusive to <code>end<\/code>\nexclusive.<\/p>\n<p>If <code>end<\/code> is not supplied, defaults to <code>(count v)<\/code>.<\/p>\n<p>This operation is O(1) and very fast, as the resulting vector shares structure\nwith the original and no trimming is done.<\/p>"
  },
  "cljs.core\/finally": {
    "type": "special form",
    "signature": [
      "[expr*]"
    ],
    "related": [
      "cljs.core\/try",
      "cljs.core\/catch",
      "cljs.core\/throw"
    ],
    "full-name": "cljs.core\/finally",
    "description-html": "<p><code>finally<\/code> should be the last form inside of a <code>try<\/code> expression. It is optional.<\/p>\n<p><code>finally<\/code> clauses are always evaluated for their side effects whether there was\nan error or not, but they are never the return value of a <code>try<\/code> expression.<\/p>"
  },
  "cljs.core\/some->>": {
    "type": "macro",
    "signature": [
      "[expr & forms]"
    ],
    "related": [
      "cljs.core\/->",
      "cljs.core\/->>",
      "cljs.core\/some->",
      "cljs.core\/some"
    ],
    "full-name": "cljs.core\/some->>",
    "description-html": "<p>When <code>expr<\/code> is not nil, threads it into the first form (via <code>-&gt;&gt;<\/code>), and when\nthat result is not nil, through the next, etc.<\/p>"
  },
  "cljs.core\/replace": {
    "signature": [
      "[smap]",
      "[smap coll]"
    ],
    "related": [
      "cljs.core\/map",
      "clojure.walk\/prewalk-replace",
      "clojure.walk\/postwalk-replace"
    ],
    "full-name": "cljs.core\/replace",
    "description-html": "<p>Given a map of replacement pairs <code>smap<\/code> and a vector\/collection <code>coll<\/code>, returns\na vector\/seq with any elements <code>=<\/code> to a key in <code>smap<\/code> replaced with the\ncorresponding val in <code>smap<\/code>.<\/p>\n<p>Returns a transducer when <code>coll<\/code> is not provided.<\/p>"
  },
  "clojure.string\/replace": {
    "signature": [
      "[s match replacement]"
    ],
    "related": [
      "cljs.core\/subs",
      "clojure.string\/split",
      "clojure.string\/replace-first"
    ],
    "full-name": "clojure.string\/replace",
    "description-html": "<p>Replaces all instance of <code>match<\/code> with <code>replacement<\/code> in <code>s<\/code>.<\/p>\n<p>The options for match \/ replacement are:<\/p>\n<table>\n<thead>\n<tr>\n<th>match<\/th>\n<th>replacement<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>string<\/td>\n<td>string<\/td>\n<\/tr>\n<tr>\n<td>regex<\/td>\n<td>string<\/td>\n<\/tr>\n<tr>\n<td>regex<\/td>\n<td>function<\/td>\n<\/tr>\n<\/tbody>\n<\/table>"
  },
  "cljs.core\/zero?": {
    "signature": [
      "[n]"
    ],
    "related": [
      "cljs.core\/pos?",
      "cljs.core\/neg?"
    ],
    "full-name": "cljs.core\/zero?",
    "description-html": "<p>Returns true if <code>n<\/code> is 0, false otherwise.<\/p>"
  },
  "cljs.core\/false?": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/true?",
      "cljs.core\/not"
    ],
    "full-name": "cljs.core\/false?",
    "description-html": "<p>Returns true if <code>x<\/code> is the value false, false otherwise.<\/p>"
  },
  "cljs.core\/max": {
    "signature": [
      "[x]",
      "[x y]",
      "[x y & more]"
    ],
    "related": [
      "cljs.core\/min",
      "cljs.core\/max-key"
    ],
    "full-name": "cljs.core\/max",
    "description-html": "<p>Returns the greatest number argument.<\/p>"
  },
  "cljs.core\/list?": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/seq?",
      "cljs.core\/sequential?",
      "cljs.core\/coll?"
    ],
    "full-name": "cljs.core\/list?",
    "description-html": "<p>Returns true if <code>x<\/code> is a list, false otherwise.<\/p>"
  },
  "cljs.core\/fn": {
    "type": "special form",
    "signature": [
      "[name? [params*] prepost-map? body]",
      "[name? ([params*] prepost-map? body)+]"
    ],
    "related": [
      "cljs.core\/defn",
      "cljs.core\/defn-"
    ],
    "todo": "need to provide a link to some function definition examples; we probably need\na whole page dedicated to fn expressions",
    "full-name": "cljs.core\/fn",
    "description-html": "<p>Defines a function.<\/p>\n<p><code>name?<\/code> is an optional name of the function to be used inside <code>body<\/code>. This is\nuseful for recursive calls. Note that <code>name?<\/code> in <code>fn<\/code> is not the same as the\n<code>name<\/code> argument to <code>defn<\/code>, which defines a global symbol for the function.<\/p>\n<p><code>params*<\/code> are the arguments to the function and a binding form for the symbols\nthat the arguments will take inside the body of the function. Functions can have\narity of 0-20 and there is no runtime enforcement of arity when calling a\nfunction (just like in JavaScript).<\/p>\n<p><code>prepost-map?<\/code> is an optional map with optional keys <code>:pre<\/code> and <code>:post<\/code> that\ncontain collections of <a href=\"http:\/\/blog.fogus.me\/2009\/12\/21\/clojures-pre-and-post\/\">pre or post conditions<\/a>\nfor the function.<\/p>\n<p><code>body<\/code> is a series of expressions that execute when the function is called. The\narguments to the function are mapped to symbols in <code>params*<\/code> and are available\nin <code>body<\/code>. The value of the last expression in <code>body<\/code> is the return value of\ncalling the function.<\/p>"
  },
  "cljs.core\/int": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/char",
      "cljs.core\/integer?"
    ],
    "full-name": "cljs.core\/int",
    "description-html": "<p>Coerces <code>x<\/code> to an integer by stripping decimal places.<\/p>"
  },
  "cljs.core\/second": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/first",
      "cljs.core\/nth",
      "cljs.core\/fnext",
      "cljs.core\/next"
    ],
    "full-name": "cljs.core\/second",
    "description-html": "<p>Returns the second item in <code>coll<\/code>.<\/p>\n<p>Same as <code>(first (next coll))<\/code><\/p>"
  },
  "cljs.core\/next": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/rest",
      "cljs.core\/first",
      "cljs.core\/fnext"
    ],
    "full-name": "cljs.core\/next",
    "description-html": "<p>Returns a sequence of the items after the first and calls <code>seq<\/code> on its argument.<\/p>\n<p>Returns nil if <code>coll<\/code> is empty.<\/p>"
  },
  "cljs.core\/vec": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/vector",
      "cljs.core\/vector?",
      "cljs.core\/vector-of"
    ],
    "full-name": "cljs.core\/vec",
    "description-html": "<p>Creates a new vector containing the contents of <code>coll<\/code><\/p>"
  },
  "cljs.core\/ffirst": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/first",
      "cljs.core\/fnext",
      "cljs.core\/nfirst"
    ],
    "full-name": "cljs.core\/ffirst",
    "description-html": "<p>Same as <code>(first (first coll))<\/code>.<\/p>"
  },
  "cljs.core\/reductions": {
    "signature": [
      "[f coll]",
      "[f init coll]"
    ],
    "related": [
      "cljs.core\/reduce"
    ],
    "full-name": "cljs.core\/reductions",
    "description-html": "<p>Returns a lazy sequence of the intermediate values of the reduction (as per\n<code>reduce<\/code>) of <code>coll<\/code> by <code>f<\/code>, starting with <code>init<\/code>.<\/p>"
  },
  "cljs.core\/key": {
    "signature": [
      "[map-entry]"
    ],
    "related": [
      "cljs.core\/keys"
    ],
    "full-name": "cljs.core\/key",
    "description-html": "<p>Returns the key of the map entry.<\/p>"
  },
  "cljs.core\/interleave": {
    "signature": [
      "[c1 c2]",
      "[c1 c2 & colls]"
    ],
    "related": [
      "cljs.core\/interpose",
      "cljs.core\/zipmap"
    ],
    "full-name": "cljs.core\/interleave",
    "description-html": "<p>Returns a lazy seq of the first item in each collection, then the second items,\nthen the third, etc.<\/p>"
  },
  "clojure.set\/subset?": {
    "signature": [
      "[a b]"
    ],
    "related": [
      "cljs.core\/set",
      "cljs.core\/set?",
      "clojure.set\/superset?"
    ],
    "full-name": "clojure.set\/subset?",
    "description-html": "<p>Returns true if <code>a<\/code> is a subset of <code>b<\/code>, false otherwise.<\/p>\n<p>In other words, returns true if all the elements of <code>a<\/code> can be found in <code>b<\/code>.<\/p>"
  },
  "cljs.core\/js-delete": {
    "signature": [
      "[obj key]"
    ],
    "related": [
      "cljs.core\/dissoc"
    ],
    "full-name": "cljs.core\/js-delete",
    "description-html": "<p>Deletes property <code>key<\/code> in JavaScript object <code>obj<\/code>.<\/p>\n<p>Uses the JavaScript <code>delete<\/code> operator.<\/p>"
  },
  "cljs.core\/split-with": {
    "signature": [
      "[pred coll]"
    ],
    "related": [
      "cljs.core\/split-at",
      "clojure.string\/split",
      "cljs.core\/take-while",
      "cljs.core\/drop-while"
    ],
    "full-name": "cljs.core\/split-with",
    "description-html": "<p>Returns a vector of <code>[(take-while pred coll) (drop-while pred coll)]<\/code><\/p>"
  },
  "clojure.string\/lower-case": {
    "signature": [
      "[s]"
    ],
    "full-name": "clojure.string\/lower-case",
    "description-html": "<p>Converts string to all lower-case.<\/p>"
  },
  "cljs.core\/not": {
    "signature": [
      "[x]"
    ],
    "return type": "boolean",
    "related": [
      "cljs.core\/complement",
      "cljs.core\/false?"
    ],
    "full-name": "cljs.core\/not",
    "description-html": "<p>Returns true if <code>x<\/code> is logical false, false otherwise.<\/p>"
  },
  "cljs.core\/complement": {
    "signature": [
      "[f]"
    ],
    "related": [
      "cljs.core\/not"
    ],
    "full-name": "cljs.core\/complement",
    "description-html": "<p>Takes a function <code>f<\/code> and returns a function that takes the same arguments as\n<code>f<\/code>, has the same effects, if any, and returns the opposite truth value.<\/p>"
  },
  "cljs.core\/neg?": {
    "signature": [
      "[n]"
    ],
    "related": [
      "cljs.core\/pos?",
      "cljs.core\/zero?"
    ],
    "full-name": "cljs.core\/neg?",
    "description-html": "<p>Returns true if <code>n<\/code> is less than 0, false otherwise.<\/p>"
  },
  "cljs.core\/compare": {
    "signature": [
      "[x y]"
    ],
    "related": [
      "cljs.core\/sort-by",
      "cljs.core\/sorted-set-by",
      "cljs.core\/sorted-map-by"
    ],
    "full-name": "cljs.core\/compare",
    "description-html": "<p>Comparator.<\/p>\n<p>Returns a negative number, zero, or a positive number when <code>x<\/code> is logically\n&quot;less than&quot;, &quot;equal to&quot;, or &quot;greater than&quot; <code>y<\/code>.<\/p>\n<p>Uses <code>IComparable<\/code> if available and <code>google.array.defaultCompare<\/code> for objects of\nthe same type. nil is treated as a special case and is always less than any\nother object.<\/p>"
  },
  "clojure.string\/escape": {
    "signature": [
      "[s cmap]"
    ],
    "full-name": "clojure.string\/escape",
    "description-html": "<p>Return a new string, using <code>cmap<\/code> to escape each character <code>ch<\/code> from <code>s<\/code> as follows:<\/p>\n<p>If <code>(cmap ch)<\/code> is nil, append ch to the new string.<\/p>\n<p>If <code>(cmap ch)<\/code> is non-nil, append <code>(str (cmap ch))<\/code> instead.<\/p>"
  },
  "cljs.core\/if-not": {
    "type": "macro",
    "signature": [
      "[test then]",
      "[test then else]"
    ],
    "related": [
      "cljs.core\/if",
      "cljs.core\/when-not"
    ],
    "full-name": "cljs.core\/if-not",
    "description-html": "<p>If <code>test<\/code> is false or nil, evaluates and returns <code>then<\/code>. Otherwise, evaluates\nand returns <code>else<\/code>. <code>else<\/code> defaults to nil if not provided.<\/p>"
  },
  "cljs.core\/sorted-map": {
    "signature": [
      "[& keyvals]"
    ],
    "related": [
      "cljs.core\/sorted-map-by",
      "cljs.core\/subseq",
      "cljs.core\/rsubseq",
      "cljs.core\/sorted-set",
      "cljs.core\/array-map",
      "cljs.core\/hash-map"
    ],
    "full-name": "cljs.core\/sorted-map",
    "description-html": "<p>Returns a new sorted map with supplied mappings.<\/p>\n<p><code>keyvals<\/code> must be an even number of forms.<\/p>"
  },
  "cljs.core\/select-keys": {
    "signature": [
      "[map keys]"
    ],
    "full-name": "cljs.core\/select-keys",
    "description-html": "<p>Returns a map containing only those entries in <code>map<\/code> whose key is in <code>keys<\/code>.<\/p>"
  },
  "cljs.core\/realized?": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/lazy-seq"
    ],
    "full-name": "cljs.core\/realized?",
    "description-html": "<p>Returns true if a value has been produced for a lazy sequence.<\/p>"
  },
  "cljs.core\/sorted-map-by": {
    "signature": [
      "[comparator & keyvals]"
    ],
    "related": [
      "cljs.core\/sorted-map",
      "cljs.core\/subseq",
      "cljs.core\/rsubseq",
      "cljs.core\/sorted-set-by"
    ],
    "full-name": "cljs.core\/sorted-map-by",
    "description-html": "<p>Returns a new sorted map with supplied mappings, using the supplied comparator\nfunction.<\/p>\n<p><code>keyvals<\/code> must be an even number of forms.<\/p>"
  },
  "cljs.core\/assoc": {
    "signature": [
      "[coll k v]",
      "[coll k v & kvs]"
    ],
    "related": [
      "cljs.core\/assoc-in",
      "cljs.core\/dissoc",
      "cljs.core\/merge"
    ],
    "full-name": "cljs.core\/assoc",
    "description-html": "<p>assoc(iate)<\/p>\n<p>When applied to a map, returns a new map that contains the mapping of key(s) to\nval(s).<\/p>\n<p>Has no effect on the map type (hashed\/sorted).<\/p>\n<p>When applied to a vector, returns a new vector that contains value <code>v<\/code> at index\n<code>k<\/code>.<\/p>"
  },
  "cljs.core\/interpose": {
    "signature": [
      "[sep coll]"
    ],
    "related": [
      "cljs.core\/interleave",
      "clojure.string\/join"
    ],
    "full-name": "cljs.core\/interpose",
    "description-html": "<p>Returns a lazy seq of the elements of <code>coll<\/code> separated by <code>sep<\/code>.<\/p>"
  },
  "cljs.core\/rem": {
    "signature": [
      "[n d]"
    ],
    "related": [
      "cljs.core\/quot",
      "cljs.core\/mod"
    ],
    "full-name": "cljs.core\/rem",
    "description-html": "<p>Returns the remainder of dividing numerator <code>n<\/code> by denominator <code>d<\/code>.<\/p>\n<p>Returns <code>NaN<\/code> when <code>d<\/code> is 0 (divide by 0 error).<\/p>"
  },
  "cljs.core\/disj": {
    "signature": [
      "[coll]",
      "[coll k]",
      "[coll k & ks]"
    ],
    "related": [
      "cljs.core\/dissoc",
      "cljs.core\/disj!",
      "clojure.set\/difference"
    ],
    "full-name": "cljs.core\/disj",
    "description-html": "<p>disj(oin). Returns a new set of the same (hashed\/sorted) type, that does not\ncontain key(s).<\/p>"
  },
  "cljs.core\/cons": {
    "signature": [
      "[x coll]"
    ],
    "related": [
      "cljs.core\/conj"
    ],
    "full-name": "cljs.core\/cons",
    "description-html": "<p>Returns a new sequence where <code>x<\/code> is the first element and <code>coll<\/code> is the rest.<\/p>"
  },
  "cljs.core\/coll?": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/seq?",
      "cljs.core\/list?",
      "cljs.core\/sequential?"
    ],
    "full-name": "cljs.core\/coll?",
    "description-html": "<p>Returns true if <code>x<\/code> is a collection, false otherwise.<\/p>\n<p>Lists, maps, sets, and vectors are collections.<\/p>"
  },
  "clojure.set\/union": {
    "signature": [
      "[]",
      "[s1]",
      "[s1 s2]",
      "[s1 s2 & sets]"
    ],
    "related": [
      "clojure.set\/intersection",
      "clojure.set\/difference",
      "clojure.set\/superset?"
    ],
    "full-name": "clojure.set\/union",
    "description-html": "<p>Return a set that is the union of the input sets.<\/p>"
  },
  "cljs.core\/assoc-in": {
    "signature": [
      "[m [k & ks] v]"
    ],
    "related": [
      "cljs.core\/assoc",
      "cljs.core\/update-in",
      "cljs.core\/dissoc-in",
      "cljs.core\/get-in"
    ],
    "full-name": "cljs.core\/assoc-in",
    "description-html": "<p>Associates a value in a nested associative structure, where <code>ks<\/code> is a sequence\nof keys and <code>v<\/code> is the new value. Returns a new nested structure.<\/p>\n<p>If any levels do not exist, hash-maps will be created.<\/p>"
  },
  "cljs.core\/reverse": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/rseq"
    ],
    "full-name": "cljs.core\/reverse",
    "description-html": "<p>Returns a sequence of the items in <code>coll<\/code> in reverse order. Not lazy.<\/p>"
  },
  "cljs.core\/->>": {
    "type": "macro",
    "signature": [
      "[x & forms]"
    ],
    "related": [
      "cljs.core\/->"
    ],
    "todo": "add threading macro animations link here",
    "full-name": "cljs.core\/->>",
    "description-html": "<p>The thread-last macro &quot;threads&quot; an expression through several forms as the last\nitem in a list.<\/p>\n<p>Inserts <code>x<\/code> as the last item in the first form, making a list of it if it is not\na list already. If there are more forms, inserts the first form as the last item\nin second form, etc.<\/p>\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code<\/th>\n      <th>Expands To<\/th><\/tr><\/thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(-&gt;&gt; x\n  (a b c)\n  d\n  (x y z))<\/pre><\/td>\n      <td><pre>\n(x y z (d (a b c x)))<\/pre><\/td><\/tr><\/tbody><\/table>"
  },
  "cljs.core\/map-indexed": {
    "signature": [
      "[f coll]"
    ],
    "related": [
      "cljs.core\/map",
      "cljs.core\/keep-indexed"
    ],
    "full-name": "cljs.core\/map-indexed",
    "description-html": "<p>Returns a lazy sequence consisting of the result of applying <code>f<\/code> to 0 and the\nfirst item of <code>coll<\/code>, followed by applying <code>f<\/code> to 1 and the second item in\n<code>coll<\/code>, etc, until <code>coll<\/code> is exhausted.<\/p>\n<p>Function <code>f<\/code> should accept 2 arguments, index and item.<\/p>"
  },
  "cljs.core\/range": {
    "signature": [
      "[]",
      "[end]",
      "[start end]",
      "[start end step]"
    ],
    "related": [
      "cljs.core\/repeat"
    ],
    "full-name": "cljs.core\/range",
    "description-html": "<p>Returns a lazy sequence of nums from <code>start<\/code> (inclusive) to <code>end<\/code> (exclusive),\nby <code>step<\/code>, where <code>start<\/code> defaults to 0, <code>step<\/code> to 1, and <code>end<\/code> to infinity.<\/p>"
  },
  "clojure.string\/reverse": {
    "signature": [
      "[s]"
    ],
    "full-name": "clojure.string\/reverse",
    "description-html": "<p>Returns <code>s<\/code> with its characters reversed.<\/p>"
  },
  "cljs.core\/when-some": {
    "type": "macro",
    "signature": [
      "[[x test] & body]"
    ],
    "related": [
      "cljs.core\/if-some"
    ],
    "full-name": "cljs.core\/when-some",
    "description-html": "<p>When <code>test<\/code> is not nil, evaluates <code>body<\/code> with <code>x<\/code> bound to the value of <code>test<\/code>.<\/p>"
  },
  "clojure.string\/trim": {
    "signature": [
      "[s]"
    ],
    "full-name": "clojure.string\/trim",
    "description-html": "<p>Removes whitespace from both ends of string.<\/p>"
  },
  "cljs.core\/throw": {
    "type": "special form",
    "signature": [
      "[expr]"
    ],
    "related": [
      "cljs.core\/try",
      "cljs.core\/catch",
      "cljs.core\/finally"
    ],
    "full-name": "cljs.core\/throw",
    "description-html": "<p><code>expr<\/code> is evaluated and thrown, hopefully to be caught by a <code>try<\/code> expression.<\/p>\n<p><code>(throw (js\/Error. &quot;Oops!&quot;))<\/code><\/p>"
  },
  "cljs.core\/and": {
    "type": "macro",
    "signature": [
      "[]",
      "[x]",
      "[x & next]"
    ],
    "related": [
      "cljs.core\/or",
      "cljs.core\/if"
    ],
    "full-name": "cljs.core\/and",
    "description-html": "<p>Evaluates arguments one at a time from left to right. If an argument returns\nlogical false (nil or false), <code>and<\/code> returns that value and doesn&#39;t evaluate any\nof the other arguments, otherwise it returns the value of the last argument.<\/p>\n<p><code>(and)<\/code> returns true.<\/p>"
  },
  "cljs.core\/reduce-kv": {
    "signature": [
      "[f init coll]"
    ],
    "related": [
      "cljs.core\/reduce"
    ],
    "full-name": "cljs.core\/reduce-kv",
    "description-html": "<p>Reduces an associative collection.<\/p>\n<p><code>f<\/code> should be a function of 3 arguments. Returns the result of applying <code>f<\/code> to\n<code>init<\/code>, the first key and the first value in <code>coll<\/code>, then applying <code>f<\/code> to that\nresult and the 2nd key and value, etc.<\/p>\n<p>If <code>coll<\/code> contains no entries, returns <code>init<\/code> and <code>f<\/code> is not called.<\/p>\n<p>Note that <code>reduce-kv<\/code> is supported on vectors, where the keys will be the\nordinals.<\/p>"
  },
  "clojure.string\/capitalize": {
    "signature": [
      "[s]"
    ],
    "full-name": "clojure.string\/capitalize",
    "description-html": "<p>Converts first character of the string to upper-case, all other characters to\nlower-case.<\/p>"
  },
  "cljs.core\/repeat": {
    "signature": [
      "[x]",
      "[n x]"
    ],
    "related": [
      "cljs.core\/repeatedly",
      "cljs.core\/cycle",
      "cljs.core\/constantly",
      "cljs.core\/dotimes"
    ],
    "full-name": "cljs.core\/repeat",
    "description-html": "<p>Returns a lazy sequence of <code>x<\/code>s.<\/p>\n<p>The length of the sequence is infinite, or <code>n<\/code> if provided.<\/p>"
  },
  "cljs.core\/first": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/rest",
      "cljs.core\/next",
      "cljs.core\/nth",
      "cljs.core\/second",
      "cljs.core\/take",
      "cljs.core\/ffirst"
    ],
    "full-name": "cljs.core\/first",
    "description-html": "<p>Returns the first item in <code>coll<\/code> and calls <code>seq<\/code> on its argument.<\/p>\n<p>Returns nil when <code>coll<\/code> is nil.<\/p>"
  },
  "cljs.core\/butlast": {
    "signature": [
      "[s]"
    ],
    "related": [
      "cljs.core\/first",
      "cljs.core\/rest",
      "cljs.core\/last",
      "cljs.core\/next",
      "cljs.core\/drop-last",
      "cljs.core\/take-last"
    ],
    "full-name": "cljs.core\/butlast",
    "description-html": "<p>Returns a sequence of all but the last item in <code>s<\/code>.<\/p>\n<p><code>butlast<\/code> runs in linear time.<\/p>"
  },
  "cljs.core\/seq?": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/seq",
      "cljs.core\/sequential?",
      "cljs.core\/vector?",
      "cljs.core\/coll?",
      "cljs.core\/list?",
      "cljs.core\/map?",
      "cljs.core\/set?"
    ],
    "full-name": "cljs.core\/seq?",
    "description-html": "<p>Returns true if <code>x<\/code> is a sequence, false otherwise.<\/p>\n<p>All collections can be converted into a sequence using <code>seq<\/code>.<\/p>"
  },
  "cljs.core\/some-fn": {
    "signature": [
      "[p]",
      "[p1 p2]",
      "[p1 p2 p3]",
      "[p1 p2 p3 & ps]"
    ],
    "related": [
      "cljs.core\/every-pred",
      "cljs.core\/some",
      "cljs.core\/or"
    ],
    "full-name": "cljs.core\/some-fn",
    "description-html": "<p>Takes a set of predicate functions and returns a function <code>f<\/code> that returns the\nfirst logical true value returned by one of its composing predicates against any\nof its arguments, else it returns logical false.<\/p>\n<p>Note that <code>f<\/code> is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates.<\/p>"
  },
  "cljs.core\/case": {
    "type": "macro",
    "signature": [
      "[e & clauses]"
    ],
    "related": [
      "cljs.core\/cond",
      "cljs.core\/condp"
    ],
    "full-name": "cljs.core\/case",
    "description-html": "<p>Takes an expression and a set of clauses. Each clause can take the form of\neither:<\/p>\n<p><code>test-constant result-expr<\/code><\/p>\n<p><code>(test-constant1 ... test-constantN)  result-expr<\/code><\/p>\n<p>The test-constants are not evaluated. They must be compile-time literals, and\nneed not be quoted. If the expression is equal to a test-constant, the\ncorresponding <code>result-expr<\/code> is returned. A single default expression can follow\nthe clauses, and its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an Error is thrown.<\/p>\n<p>Unlike <code>cond<\/code> and <code>condp<\/code>, <code>case<\/code> does a constant-time dispatch, the clauses are\nnot considered sequentially. All manner of constant expressions are acceptable\nin <code>case<\/code>, including numbers, strings, symbols, keywords, and ClojureScript\ncomposites thereof. Note that since lists are used to group multiple constants\nthat map to the same expression, a vector can be used to match a list if needed.\nThe test-constants need not be all of the same type.<\/p>"
  },
  "cljs.core\/take-last": {
    "signature": [
      "[n coll]"
    ],
    "related": [
      "cljs.core\/last",
      "cljs.core\/butlast",
      "cljs.core\/drop-last"
    ],
    "todo": "Would be nice to list the O(n) time for all the collection types here instead of\njust saying \"it depends\".",
    "full-name": "cljs.core\/take-last",
    "description-html": "<p>Returns a sequence of the last <code>n<\/code> items in <code>coll<\/code>.<\/p>\n<p>Depending on the type of collection, <code>take-last<\/code> may be no faster than linear\ntime. For vectors, please use <code>subvec<\/code>.<\/p>"
  },
  "cljs.core\/bit-not": {
    "signature": [
      "[x]"
    ],
    "full-name": "cljs.core\/bit-not",
    "description-html": "<p>Bitwise complement<\/p>"
  },
  "cljs.core\/counted?": {
    "signature": [
      "[x]"
    ],
    "full-name": "cljs.core\/counted?",
    "description-html": "<p>Returns true if <code>x<\/code> executes <code>count<\/code> in constant time, false otherwise.<\/p>\n<p>Lists, maps, sets, strings, and vectors can be counted in constant time.<\/p>"
  },
  "cljs.core\/if-let": {
    "type": "macro",
    "signature": [
      "[[x test] then]",
      "[[x test] then else]"
    ],
    "related": [
      "cljs.core\/when-let",
      "cljs.core\/if"
    ],
    "full-name": "cljs.core\/if-let",
    "description-html": "<p>When <code>test<\/code> is logical true, evaluates <code>then<\/code> with the value of <code>test<\/code> bound to\n<code>x<\/code>. Otherwise, evaluates <code>else<\/code> with no bindings.<\/p>\n<p><code>else<\/code> defaults to nil.<\/p>"
  },
  "cljs.core\/or": {
    "type": "macro",
    "signature": [
      "[]",
      "[x]",
      "[x & next]"
    ],
    "related": [
      "cljs.core\/and",
      "cljs.core\/if"
    ],
    "full-name": "cljs.core\/or",
    "description-html": "<p>Evaluates arguments one at a time from left to right. If an argument returns\nlogical true, <code>or<\/code> returns that value and doesn&#39;t evaluate any of the other\narguments, otherwise it returns the value of the last argument.<\/p>\n<p><code>(or)<\/code> returns nil.<\/p>"
  },
  "cljs.core\/name": {
    "signature": [
      "[x]"
    ],
    "full-name": "cljs.core\/name",
    "description-html": "<p>Returns a string value of a keyword, string, or symbol.<\/p>\n<p><code>(name :foo)<\/code> =&gt; <code>&quot;foo&quot;<\/code><\/p>\n<p><code>(name &quot;foo&quot;)<\/code> =&gt; <code>&quot;foo&quot;<\/code><\/p>\n<p><code>(name &#39;foo)<\/code> =&gt; <code>&quot;foo&quot;<\/code><\/p>"
  },
  "cljs.core\/subs": {
    "signature": [
      "[s start]",
      "[s start end]"
    ],
    "full-name": "cljs.core\/subs",
    "description-html": "<p>Returns the substring of <code>s<\/code> beginning at <code>start<\/code> inclusive, and ending at <code>end<\/code>\nexclusive.<\/p>\n<p><code>end<\/code> defaults to the length of the string.<\/p>"
  },
  "cljs.core\/merge": {
    "signature": [
      "[& maps]"
    ],
    "related": [
      "cljs.core\/merge-with",
      "cljs.core\/hash-map"
    ],
    "full-name": "cljs.core\/merge",
    "description-html": "<p>Returns a map that consists of the rest of the maps <code>conj<\/code>-ed onto the first.<\/p>\n<p>If a key occurs in more than one map, the mapping from the rightmost map will\n&quot;win&quot;.<\/p>"
  },
  "cljs.core\/+": {
    "signature": [
      "[]",
      "[x]",
      "[x y]",
      "[x y & more]"
    ],
    "related": [
      "cljs.core\/*",
      "cljs.core\/-"
    ],
    "full-name": "cljs.core\/+",
    "description-html": "<p>Returns the sum of nums.<\/p>\n<p><code>(+)<\/code> returns 0.<\/p>"
  },
  "cljs.core\/every?": {
    "signature": [
      "[pred coll]"
    ],
    "related": [
      "cljs.core\/some",
      "cljs.core\/not-any?"
    ],
    "full-name": "cljs.core\/every?",
    "description-html": "<p>Returns true if <code>(pred x)<\/code> is logical true for every <code>x<\/code> in <code>coll<\/code>, else false.<\/p>"
  },
  "cljs.core\/sort-by": {
    "signature": [
      "[keyfn coll]",
      "[keyfn comp coll]"
    ],
    "related": [
      "cljs.core\/sort",
      "cljs.core\/compare"
    ],
    "full-name": "cljs.core\/sort-by",
    "description-html": "<p>Returns a sorted sequence of the items in <code>coll<\/code>, where the sort order is\ndetermined by comparing <code>(keyfn item)<\/code>.<\/p>\n<p><code>comp<\/code> can be boolean-valued comparison function, or a -\/0\/+ valued comparator.<\/p>\n<p><code>comp<\/code> defaults to <code>compare<\/code>.<\/p>"
  },
  "cljs.core\/>=": {
    "signature": [
      "[x]",
      "[x y]",
      "[x y & more]"
    ],
    "related": [
      "cljs.core\/>"
    ],
    "full-name": "cljs.core\/>=",
    "description-html": "<p>Returns true if each successive number argument is less than or equal to the\nprevious one, false otherwise.<\/p>"
  },
  "cljs.core\/bit-flip": {
    "signature": [
      "[x n]"
    ],
    "full-name": "cljs.core\/bit-flip",
    "description-html": "<p>Flip bit at index <code>n<\/code><\/p>"
  },
  "cljs.core\/hash-set": {
    "signature": [
      "[]",
      "[& keys]"
    ],
    "related": [
      "cljs.core\/set",
      "cljs.core\/sorted-set"
    ],
    "full-name": "cljs.core\/hash-set",
    "description-html": "<p>Returns a new hash set with supplied <code>keys<\/code>.<\/p>\n<p>Any equal keys are handled as if by repeated uses of <code>conj<\/code>.<\/p>"
  },
  "cljs.core\/list": {
    "signature": [
      "[& items]"
    ],
    "related": [
      "cljs.core\/vector",
      "cljs.core\/list?"
    ],
    "full-name": "cljs.core\/list",
    "description-html": "<p>Creates a new list containing <code>items<\/code>.<\/p>"
  },
  "cljs.core\/rsubseq": {
    "signature": [
      "[sc test key]",
      "[sc start-test start-key end-test end-key]"
    ],
    "related": [
      "cljs.core\/subseq"
    ],
    "full-name": "cljs.core\/rsubseq",
    "description-html": "<p><code>sc<\/code> must be a sorted collection.<\/p>\n<p><code>test<\/code>, <code>start-test<\/code>, <code>end-test<\/code> must be <code>&lt;<\/code>, <code>&lt;=<\/code>, <code>&gt;<\/code> or <code>&gt;=<\/code>.<\/p>\n<p>Returns a reverse sequence of those entries with keys <code>ek<\/code> for which\n<code>(test (.. sc comparator (compare ek key)) 0)<\/code> is true.<\/p>"
  },
  "cljs.core\/vector": {
    "signature": [
      "[& args]"
    ],
    "related": [
      "cljs.core\/vec",
      "cljs.core\/vector?",
      "cljs.core\/vector-of",
      "cljs.core\/pop",
      "cljs.core\/into"
    ],
    "full-name": "cljs.core\/vector",
    "description-html": "<p>Creates a new vector containing <code>args<\/code>.<\/p>"
  },
  "cljs.core\/bit-shift-left": {
    "signature": [
      "[x n]"
    ],
    "related": [
      "cljs.core\/bit-shift-right"
    ],
    "full-name": "cljs.core\/bit-shift-left",
    "description-html": "<p>Bitwise shift left<\/p>"
  },
  "cljs.core\/bit-and": {
    "signature": [
      "[x y]"
    ],
    "related": [
      "cljs.core\/bit-or"
    ],
    "full-name": "cljs.core\/bit-and",
    "description-html": "<p>Bitwise and<\/p>"
  },
  "cljs.core\/inc": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/dec"
    ],
    "full-name": "cljs.core\/inc",
    "description-html": "<p>Returns a number one greater than <code>x<\/code>.<\/p>"
  },
  "cljs.core\/instance?": {
    "signature": [
      "[t o]"
    ],
    "related": [
      "cljs.core\/type"
    ],
    "full-name": "cljs.core\/instance?",
    "description-html": "<p>Returns true if <code>o<\/code> is an instance of type <code>t<\/code>, false otherwise.<\/p>"
  },
  "cljs.core\/update-in": {
    "signature": [
      "[m [k & ks] f]",
      "[m [k & ks] f a]",
      "[m [k & ks] f a b]",
      "[m [k & ks] f a b c]",
      "[m [k & ks] f a b c & args]"
    ],
    "related": [
      "cljs.core\/assoc-in",
      "cljs.core\/get-in"
    ],
    "full-name": "cljs.core\/update-in",
    "description-html": "<p>&quot;Updates&quot; a value in a nested associative structure, where <code>ks<\/code> is a sequence of\nkeys and <code>f<\/code> is a function that will take the old value and any supplied\narguments and return the new value. Returns a new nested structure.<\/p>\n<p>If any levels do not exist, hash-maps will be created.<\/p>"
  },
  "cljs.core\/array": {
    "signature": [
      "[& args]"
    ],
    "related": [
      "cljs.core\/aclone",
      "cljs.core\/make-array"
    ],
    "full-name": "cljs.core\/array",
    "description-html": "<p>Creates a JavaScript array containing <code>args<\/code>.<\/p>"
  },
  "cljs.core\/every-pred": {
    "signature": [
      "[p]",
      "[p1 p2]",
      "[p1 p2 p3]",
      "[p1 p2 p3 & ps]"
    ],
    "related": [
      "cljs.core\/some-fn",
      "cljs.core\/and"
    ],
    "full-name": "cljs.core\/every-pred",
    "description-html": "<p>Takes a set of predicate functions and returns a function <code>f<\/code> that returns true\nif all of its composing predicates return a logical true value against all of\nits arguments, else it returns false.<\/p>\n<p>Note that <code>f<\/code> is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates.<\/p>"
  },
  "clojure.set\/select": {
    "signature": [
      "[pred xset]"
    ],
    "related": [
      "cljs.core\/filter"
    ],
    "full-name": "clojure.set\/select",
    "description-html": "<p>Returns a set of the elements for which <code>pred<\/code> is true.<\/p>"
  },
  "cljs.core\/val": {
    "signature": [
      "[map-entry]"
    ],
    "related": [
      "cljs.core\/vals"
    ],
    "full-name": "cljs.core\/val",
    "description-html": "<p>Returns the value in the map entry.<\/p>"
  },
  "cljs.core\/list*": {
    "signature": [
      "[args]",
      "[a args]",
      "[a b args]",
      "[a b c args]",
      "[a b c d & more]"
    ],
    "related": [
      "cljs.core\/list"
    ],
    "full-name": "cljs.core\/list*",
    "description-html": "<p>Creates a new list containing the items prepended to the rest, the last of which\nwill be treated as a sequence.<\/p>"
  },
  "cljs.core\/dotimes": {
    "type": "macro",
    "signature": [
      "[[name n] & body]"
    ],
    "related": [
      "cljs.core\/repeat",
      "cljs.core\/for",
      "cljs.core\/doseq"
    ],
    "full-name": "cljs.core\/dotimes",
    "description-html": "<p>Repeatedly executes <code>body<\/code> (presumably for side-effects) with <code>name<\/code> bound to\nintegers from 0 through <code>n<\/code>-1.<\/p>"
  },
  "cljs.core\/min-key": {
    "signature": [
      "[k x]",
      "[k x y]",
      "[k x y & more]"
    ],
    "related": [
      "cljs.core\/min",
      "cljs.core\/max-key"
    ],
    "full-name": "cljs.core\/min-key",
    "description-html": "<p>Returns the <code>x<\/code> for which <code>(k x)<\/code> is least.<\/p>\n<p><code>(k x)<\/code> should return a number.<\/p>"
  },
  "cljs.core\/add-watch": {
    "signature": [
      "[a key f]"
    ],
    "related": [
      "cljs.core\/remove-watch"
    ],
    "full-name": "cljs.core\/add-watch",
    "description-html": "<p>Adds a watch function <code>f<\/code> to atom <code>a<\/code> that will execute when the value of <code>a<\/code>\nchanges.<\/p>\n<p>The watch function takes 4 arguments: a key, the atom, its old state, and its\nnew state.<\/p>\n<p><code>key<\/code> should be a keyword and can be used with <code>remove-watch<\/code> to remove the\nwatch function.<\/p>"
  },
  "cljs.core\/aget": {
    "signature": [
      "[array i]",
      "[array i & idxs]"
    ],
    "related": [
      "cljs.core\/aset",
      "cljs.core\/get",
      "cljs.core\/nth"
    ],
    "full-name": "cljs.core\/aget",
    "description-html": "<p>Returns the value at index <code>i<\/code> from JavaScript arrays and objects.<\/p>\n<p>Can be used to retrieve nested properties from JavaScript objects, ie: <code>(aget\njs\/document &quot;location&quot; &quot;href&quot;)<\/code><\/p>"
  },
  "cljs.core\/some": {
    "signature": [
      "[pred coll]"
    ],
    "related": [
      "cljs.core\/every?",
      "cljs.core\/not-any?",
      "cljs.core\/keep",
      "cljs.core\/keep-indexed",
      "cljs.core\/some-fn"
    ],
    "full-name": "cljs.core\/some",
    "description-html": "<p>Returns the first logical true value of <code>(pred x)<\/code> for any <code>x<\/code> in <code>coll<\/code>, else\nnil.<\/p>\n<p>A common idiom is to use a set as pred, for example this will return <code>:fred<\/code> if\n<code>:fred<\/code> is in the sequence, otherwise nil: <code>(some #{:fred} coll)<\/code><\/p>"
  },
  "cljs.core\/remove-watch": {
    "signature": [
      "[a key]"
    ],
    "related": [
      "cljs.core\/add-watch"
    ],
    "full-name": "cljs.core\/remove-watch",
    "description-html": "<p>Removes a watch function (set by <code>add-watch<\/code>) from atom <code>a<\/code>.<\/p>"
  },
  "cljs.core\/drop": {
    "signature": [
      "[n]",
      "[n coll]"
    ],
    "related": [
      "cljs.core\/take",
      "cljs.core\/drop-last",
      "cljs.core\/drop-while",
      "cljs.core\/nthnext",
      "cljs.core\/nthrest"
    ],
    "full-name": "cljs.core\/drop",
    "description-html": "<p>Returns a lazy sequence of all but the first <code>n<\/code> items in <code>coll<\/code>.<\/p>\n<p>Returns a stateful transducer when no collection is provided.<\/p>"
  },
  "cljs.core\/comp": {
    "signature": [
      "[]",
      "[f]",
      "[f g]",
      "[f g h]",
      "[f1 f2 f3 & fs]"
    ],
    "related": [
      "cljs.core\/partial",
      "cljs.core\/juxt"
    ],
    "todo": "this needs work",
    "full-name": "cljs.core\/comp",
    "description-html": "<p>Takes a set of functions (<code>fn<\/code>s) and returns a function that is the composition\nof those functions.<\/p>\n<p>The returned function takes a variable number of arguments, applies the\nrightmost of <code>fn<\/code>s to the arguments, the next <code>fn<\/code> (right-to-left) to the\nresult, etc.<\/p>\n<p><code>((comp a b c) x y)<\/code> =&gt; <code>(a (b (c x y)))<\/code><\/p>"
  },
  "cljs.core\/array?": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/object?"
    ],
    "full-name": "cljs.core\/array?",
    "description-html": "<p>Returns true if <code>x<\/code> is a JavaScript array, false otherwise.<\/p>"
  },
  "cljs.core\/char": {
    "signature": [
      "[x]"
    ],
    "full-name": "cljs.core\/char",
    "description-html": "<p>Coerce to char<\/p>"
  },
  "cljs.core\/==": {
    "signature": [
      "[x]",
      "[x y]",
      "[x y & more]"
    ],
    "related": [
      "cljs.core\/=",
      "cljs.core\/identical?"
    ],
    "full-name": "cljs.core\/==",
    "description-html": "<p>Returns true if all arguments have the same value, false otherwise.<\/p>\n<p>Behavior on non-number arguments is undefined.<\/p>"
  },
  "cljs.core\/mapcat": {
    "signature": [
      "[f]",
      "[f & colls]"
    ],
    "related": [
      "cljs.core\/map",
      "cljs.core\/concat"
    ],
    "full-name": "cljs.core\/mapcat",
    "description-html": "<p>Returns the result of applying <code>concat<\/code> to the result of applying <code>map<\/code> to <code>f<\/code>\nand <code>colls<\/code>.<\/p>\n<p>Function <code>f<\/code> should return a collection.<\/p>\n<p>Returns a transducer when no collections are provided.<\/p>"
  },
  "cljs.core\/keep": {
    "signature": [
      "[f]",
      "[f coll]"
    ],
    "related": [
      "cljs.core\/keep-indexed",
      "cljs.core\/map",
      "cljs.core\/filter"
    ],
    "full-name": "cljs.core\/keep",
    "description-html": "<p>Returns a lazy sequence of the non-nil results of <code>(f item)<\/code>. Note, this means\nfalse return values will be included.<\/p>\n<p><code>f<\/code> must be free of side-effects.<\/p>\n<p>Returns a transducer when no collection is provided.<\/p>"
  },
  "clojure.string\/replace-first": {
    "signature": [
      "[s match replacement]"
    ],
    "full-name": "clojure.string\/replace-first",
    "description-html": "<p>Replaces the first instance of <code>match<\/code> with <code>replacement<\/code> in <code>s<\/code>.<\/p>\n<p>The options for match \/ replacement are:<\/p>\n<table>\n<thead>\n<tr>\n<th>match<\/th>\n<th>replacement<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>string<\/td>\n<td>string<\/td>\n<\/tr>\n<tr>\n<td>regex<\/td>\n<td>string<\/td>\n<\/tr>\n<tr>\n<td>regex<\/td>\n<td>function<\/td>\n<\/tr>\n<\/tbody>\n<\/table>"
  },
  "clojure.string\/join": {
    "signature": [
      "[coll]",
      "[separator coll]"
    ],
    "full-name": "clojure.string\/join",
    "description-html": "<p>Returns a string of all elements in <code>coll<\/code>, as returned by <code>(seq coll)<\/code>,\nseparated by an optional separator.<\/p>"
  },
  "cljs.core\/some?": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/true?",
      "cljs.core\/nil?"
    ],
    "full-name": "cljs.core\/some?",
    "description-html": "<p>Returns true if <code>x<\/code> is not nil, false otherwise.<\/p>"
  },
  "cljs.core\/str": {
    "signature": [
      "[]",
      "[x]",
      "[x & ys]"
    ],
    "full-name": "cljs.core\/str",
    "description-html": "<p><code>(str)<\/code> and <code>(str nil)<\/code> return the empty string.<\/p>\n<p><code>(str x)<\/code> returns <code>x.toString()<\/code>.<\/p>\n<p>With more than one argument, returns the concatenation of the <code>str<\/code> values of\nthe arguments.<\/p>"
  },
  "cljs.core\/<": {
    "signature": [
      "[x]",
      "[x y]",
      "[x y & more]"
    ],
    "related": [
      "cljs.core\/<="
    ],
    "full-name": "cljs.core\/<",
    "description-html": "<p>Returns true if each successive number argument is greater than the previous\none, false otherwise.<\/p>"
  },
  "cljs.core\/re-seq": {
    "signature": [
      "[re s]"
    ],
    "related": [
      "cljs.core\/re-find",
      "cljs.core\/re-groups",
      "cljs.core\/re-pattern",
      "cljs.core\/re-matcher",
      "cljs.core\/re-matches",
      "cljs.core\/subs",
      "clojure.string\/split"
    ],
    "full-name": "cljs.core\/re-seq",
    "description-html": "<p>Returns a lazy sequence of successive matches of regex <code>re<\/code> in string <code>s<\/code>.<\/p>"
  },
  "cljs.core\/rest": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/next",
      "cljs.core\/first",
      "cljs.core\/drop",
      "cljs.core\/pop"
    ],
    "full-name": "cljs.core\/rest",
    "description-html": "<p>Returns a possibly empty sequence of the items after the first item.<\/p>\n<p>Calls <code>seq<\/code> on its argument.<\/p>"
  },
  "clojure.set\/intersection": {
    "signature": [
      "[s1]",
      "[s1 s2]",
      "[s1 s2 & sets]"
    ],
    "related": [
      "clojure.set\/union",
      "clojure.set\/difference",
      "clojure.set\/superset?",
      "clojure.set\/project"
    ],
    "full-name": "clojure.set\/intersection",
    "description-html": "<p>Return a set that is the intersection of the input sets.<\/p>"
  },
  "cljs.core\/even?": {
    "signature": [
      "[n]"
    ],
    "related": [
      "cljs.core\/odd?"
    ],
    "full-name": "cljs.core\/even?",
    "description-html": "<p>Returns true if <code>n<\/code> is an even number.<\/p>\n<p>Throws an exception if <code>n<\/code> is not an integer.<\/p>"
  },
  "cljs.core\/>": {
    "signature": [
      "[x]",
      "[x y]",
      "[x y & more]"
    ],
    "related": [
      "cljs.core\/>="
    ],
    "full-name": "cljs.core\/>",
    "description-html": "<p>Returns true if each successive number argument is less than the previous\none, false otherwise.<\/p>"
  },
  "cljs.core\/doseq": {
    "type": "macro",
    "signature": [
      "[seq-exprs & body]"
    ],
    "related": [
      "cljs.core\/doall",
      "cljs.core\/dorun",
      "cljs.core\/for",
      "cljs.core\/dotimes"
    ],
    "todo": "This needs a better explanation and example.",
    "full-name": "cljs.core\/doseq",
    "description-html": "<p>Repeatedly executes <code>body<\/code> (presumably for side-effects) with bindings and\nfiltering as provided by <code>for<\/code>. Does not retain the head of the sequence.<\/p>\n<p>Returns nil.<\/p>"
  },
  "cljs.core\/shuffle": {
    "signature": [
      "[coll]"
    ],
    "full-name": "cljs.core\/shuffle",
    "description-html": "<p>Returns a random permutation of <code>coll<\/code>.<\/p>"
  },
  "clojure.string\/upper-case": {
    "signature": [
      "[s]"
    ],
    "full-name": "clojure.string\/upper-case",
    "description-html": "<p>Converts string to all upper-case.<\/p>"
  },
  "cljs.core\/when": {
    "type": "macro",
    "signature": [
      "[test & body]"
    ],
    "related": [
      "cljs.core\/when-not",
      "cljs.core\/when-let",
      "cljs.core\/if"
    ],
    "full-name": "cljs.core\/when",
    "description-html": "<p>Evaluates <code>test<\/code>. If logical true, evaluates <code>body<\/code> in an implicit <code>do<\/code>.<\/p>\n<p><code>when<\/code> is often used instead of <code>if<\/code> for conditions that do not have an &quot;else&quot;.<\/p>"
  },
  "cljs.core\/bit-clear": {
    "signature": [
      "[x n]"
    ],
    "related": [
      "cljs.core\/bit-set"
    ],
    "full-name": "cljs.core\/bit-clear",
    "description-html": "<p>Clear bit at index <code>n<\/code><\/p>"
  },
  "cljs.core\/sequential?": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/seq?",
      "cljs.core\/coll?"
    ],
    "full-name": "cljs.core\/sequential?",
    "description-html": "<p>Returns true if <code>coll<\/code> implements the <code>ISequential<\/code> protocol, false otherwise.<\/p>\n<p>Lists and vectors are sequential.<\/p>"
  },
  "cljs.core\/odd?": {
    "signature": [
      "[n]"
    ],
    "related": [
      "cljs.core\/even?"
    ],
    "full-name": "cljs.core\/odd?",
    "description-html": "<p>Returns true if <code>n<\/code> is an odd number.<\/p>\n<p>Throws an exception if <code>n<\/code> is not an integer.<\/p>"
  },
  "cljs.core\/pos?": {
    "signature": [
      "[n]"
    ],
    "related": [
      "cljs.core\/neg?",
      "cljs.core\/zero?"
    ],
    "full-name": "cljs.core\/pos?",
    "description-html": "<p>Returns true if <code>n<\/code> is greater than 0, false otherwise.<\/p>"
  },
  "cljs.core\/nthrest": {
    "signature": [
      "[coll n]"
    ],
    "related": [
      "cljs.core\/drop",
      "cljs.core\/nthnext",
      "cljs.core\/nth"
    ],
    "full-name": "cljs.core\/nthrest",
    "description-html": "<p>Returns the <code>nth<\/code> rest of <code>coll<\/code>.<\/p>\n<p>Returns <code>coll<\/code> when <code>n<\/code> is 0.<\/p>"
  },
  "cljs.core\/dorun": {
    "signature": [
      "[coll]",
      "[n coll]"
    ],
    "related": [
      "cljs.core\/doall"
    ],
    "full-name": "cljs.core\/dorun",
    "description-html": "<p>Forces evaluation of a lazy sequence. Often used to see the effects of a\nsequence produced via functions that have side effects.<\/p>\n<p><code>dorun<\/code> walks through the successive <code>next<\/code>s of the sequence and returns nil.<\/p>"
  },
  "cljs.core\/=": {
    "signature": [
      "[x]",
      "[x y]",
      "[x y & more]"
    ],
    "related": [
      "cljs.core\/==",
      "cljs.core\/not=",
      "cljs.core\/identical?"
    ],
    "full-name": "cljs.core\/=",
    "description-html": "<p>Returns true if the value of <code>x<\/code> equals the value of <code>y<\/code>, false otherwise.<\/p>\n<p><code>=<\/code> is a value comparison, not an identity comparison.<\/p>\n<p>All collections can be tested for value, regardless of &quot;depth&quot;.<\/p>"
  },
  "cljs.core\/set!": {
    "signature": [
      "[js-var val]"
    ],
    "related": [
      "cljs.core\/aset",
      "cljs.core\/reset!"
    ],
    "full-name": "cljs.core\/set!",
    "description-html": "<p>Sets <code>js-var<\/code> to <code>val<\/code> using the JavaScript <code>=<\/code> operator.<\/p>"
  },
  "cljs.core\/keys": {
    "signature": [
      "[hash-map]"
    ],
    "related": [
      "cljs.core\/vals"
    ],
    "full-name": "cljs.core\/keys",
    "description-html": "<p>Returns a sequence of the keys in <code>hash-map<\/code>.<\/p>"
  },
  "cljs.core\/dec": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/inc"
    ],
    "full-name": "cljs.core\/dec",
    "description-html": "<p>Returns a number one less than <code>x<\/code>.<\/p>"
  },
  "clojure.string\/split": {
    "signature": [
      "[s re]",
      "[s re limit]"
    ],
    "related": [
      "cljs.core\/subs",
      "clojure.string\/replace",
      "clojure.string\/split-lines"
    ],
    "full-name": "clojure.string\/split",
    "description-html": "<p>Splits string on a regular expression. Optional argument limit is the maximum\nnumber of splits. Not lazy. Returns vector of the splits.<\/p>"
  },
  "cljs.core\/reversible?": {
    "signature": [
      "[coll]"
    ],
    "full-name": "cljs.core\/reversible?",
    "description-html": "<p>Returns true if <code>coll<\/code> implements the <code>IReversible<\/code> protocol, false otherwise.<\/p>\n<p>Vectors, sorted maps, and sorted sets implement <code>IReversible<\/code>.<\/p>"
  },
  "cljs.core\/vector?": {
    "signature": [
      "[x]"
    ],
    "related": [
      "cljs.core\/vector",
      "cljs.core\/vec"
    ],
    "full-name": "cljs.core\/vector?",
    "description-html": "<p>Returns true if <code>x<\/code> is a vector, false otherwise.<\/p>"
  },
  "cljs.core\/fnext": {
    "signature": [
      "[coll]"
    ],
    "related": [
      "cljs.core\/ffirst",
      "cljs.core\/second"
    ],
    "full-name": "cljs.core\/fnext",
    "description-html": "<p>Same as <code>(first (next coll))<\/code><\/p>"
  },
  "clojure.string\/blank?": {
    "signature": [
      "[s]"
    ],
    "full-name": "clojure.string\/blank?",
    "description-html": "<p>True if <code>s<\/code> is nil, empty, or contains only whitespace.<\/p>"
  },
  "cljs.core\/repeatedly": {
    "signature": [
      "[f]",
      "[n f]"
    ],
    "related": [
      "cljs.core\/repeat",
      "cljs.core\/iterate",
      "cljs.core\/lazy-seq",
      "cljs.core\/dotimes",
      "cljs.core\/constantly"
    ],
    "full-name": "cljs.core\/repeatedly",
    "description-html": "<p>Takes a function <code>f<\/code> of no args, presumably with side effects, and returns an\ninfinite (or length <code>n<\/code> if supplied) lazy sequence of calls to it.<\/p>"
  },
  "cljs.core\/filter": {
    "signature": [
      "[f]",
      "[f coll]"
    ],
    "related": [
      "cljs.core\/remove",
      "cljs.core\/keep"
    ],
    "full-name": "cljs.core\/filter",
    "description-html": "<p>Returns a lazy sequence of the non-nil results of <code>(f item)<\/code>. Note, this means\nfalse return values will be included.<\/p>\n<p><code>f<\/code> must be free of side-effects.<\/p>\n<p>Returns a transducer when no collection is provided.<\/p>"
  },
  "cljs.core\/partial": {
    "signature": [
      "[f]",
      "[f arg1]",
      "[f arg1 arg2]",
      "[f arg1 arg2 arg3]",
      "[f arg1 arg2 arg3 & more]"
    ],
    "related": [
      "cljs.core\/comp",
      "cljs.core\/juxt"
    ],
    "full-name": "cljs.core\/partial",
    "description-html": "<p>Takes a function <code>f<\/code> and fewer than the normal arguments to <code>f<\/code>. Returns a\nfunction that takes a variable number of additional arguments. When called, the\nreturned function calls <code>f<\/code> with the original arguments plus the additional\narguments.<\/p>\n<p><code>((partial f a b) c d)<\/code> =&gt; <code>(f a b c d)<\/code><\/p>"
  },
  "cljs.core\/doall": {
    "signature": [
      "[coll]",
      "[n coll]"
    ],
    "related": [
      "cljs.core\/dorun",
      "cljs.core\/doseq"
    ],
    "todo": "What does `n` do here? This description needs work and probably an example.",
    "full-name": "cljs.core\/doall",
    "description-html": "<p>Forces evaluation of a lazy sequence. Often used to see the effects of a\nsequence produced via functions that have side effects.<\/p>\n<p><code>doall<\/code> walks through the successive <code>next<\/code>s of the sequence, returning the head\nand causing the entire sequence to reside in memory at one time.<\/p>"
  },
  "cljs.core\/bit-shift-right": {
    "signature": [
      "[x n]"
    ],
    "related": [
      "cljs.core\/bit-shift-left",
      "cljs.core\/unsigned-bit-shift-right"
    ],
    "full-name": "cljs.core\/bit-shift-right",
    "description-html": "<p>Bitwise shift right<\/p>"
  },
  "cljs.core\/take-while": {
    "signature": [
      "[pred]",
      "[pred coll]"
    ],
    "related": [
      "cljs.core\/drop-while",
      "cljs.core\/split-with"
    ],
    "full-name": "cljs.core\/take-while",
    "description-html": "<p>Returns a lazy sequence of successive items from <code>coll<\/code> while <code>(pred item)<\/code>\nreturns true. <code>pred<\/code> must be free of side-effects.<\/p>\n<p>Returns a transducer when no collection is provided.<\/p>"
  },
  "cljs.core\/array-map": {
    "signature": [
      "[& keyvals]"
    ],
    "related": [
      "cljs.core\/assoc",
      "cljs.core\/hash-map",
      "cljs.core\/sorted-map"
    ],
    "full-name": "cljs.core\/array-map",
    "description-html": "<p>Returns a new array map with supplied mappings.<\/p>\n<p><code>keyvals<\/code> must be an even number of forms.<\/p>"
  },
  "cljs.core\/some->": {
    "type": "macro",
    "signature": [
      "[expr & forms]"
    ],
    "related": [
      "cljs.core\/->",
      "cljs.core\/->>",
      "cljs.core\/some->>",
      "cljs.core\/some"
    ],
    "full-name": "cljs.core\/some->",
    "description-html": "<p>When <code>expr<\/code> is not nil, threads it into the first form (via <code>-&gt;<\/code>), and when that\nresult is not nil, through the next, etc.<\/p>"
  },
  "cljs.core\/ifn?": {
    "signature": [
      "[f]"
    ],
    "related": [
      "cljs.core\/fn?"
    ],
    "full-name": "cljs.core\/ifn?",
    "description-html": "<p>Returns true if <code>f<\/code> implements the <code>IFn<\/code> protocol, false otherwise.<\/p>\n<p>Functions, keywords, map, sets, and vectors can be called as functions.<\/p>"
  },
  "clojure.string\/triml": {
    "signature": [
      "[s]"
    ],
    "full-name": "clojure.string\/triml",
    "description-html": "<p>Removes whitespace from the left side of string.<\/p>"
  },
  "cljs.core\/into-array": {
    "signature": [
      "[aseq]"
    ],
    "related": [
      "cljs.core\/to-array",
      "cljs.core\/make-array"
    ],
    "full-name": "cljs.core\/into-array",
    "description-html": "<p>Returns a new JavaScript array from the elements of <code>aseq<\/code>.<\/p>"
  },
  "cljs.core\/not-any?": {
    "signature": [
      "[pred coll]"
    ],
    "related": [
      "cljs.core\/every?",
      "cljs.core\/some"
    ],
    "full-name": "cljs.core\/not-any?",
    "description-html": "<p>Returns false if <code>(pred x)<\/code> is logical true for any <code>x<\/code> in <code>coll<\/code>, else true.<\/p>"
  },
  "cljs.core\/get-validator": {
    "signature": [
      "[a]"
    ],
    "related": [
      "cljs.core\/atom",
      "cljs.core\/set-validator!"
    ],
    "full-name": "cljs.core\/get-validator",
    "description-html": "<p>Returns the validator function for atom <code>a<\/code>.<\/p>"
  },
  "cljs.core\/re-matches": {
    "signature": [
      "[re s]"
    ],
    "full-name": "cljs.core\/re-matches",
    "description-html": "<p>Returns the result of <code>(re-find re s)<\/code> if <code>re<\/code> fully matches <code>s<\/code>.<\/p>"
  },
  "cljs.core\/bit-and-not": {
    "signature": [
      "[x y]"
    ],
    "full-name": "cljs.core\/bit-and-not",
    "description-html": "<p>Bitwise and<\/p>"
  },
  "cljs.core\/drop-while": {
    "signature": [
      "[pred]",
      "[pred coll]"
    ],
    "related": [
      "cljs.core\/take-while",
      "cljs.core\/split-with"
    ],
    "full-name": "cljs.core\/drop-while",
    "description-html": "<p>Returns a lazy sequence of the items in <code>coll<\/code> starting from the first item for\nwhich <code>(pred item)<\/code> returns logical false.<\/p>\n<p>Returns a stateful transducer when no collection is provided.<\/p>"
  },
  "cljs.core\/while": {
    "type": "macro",
    "signature": [
      "[test & body]"
    ],
    "related": [
      "cljs.core\/loop"
    ],
    "full-name": "cljs.core\/while",
    "description-html": "<p>Repeatedly executes <code>body<\/code> while <code>test<\/code> expression is true. Presumes some\nside-effect will cause <code>test<\/code> to become false or nil.<\/p>\n<p>Returns nil.<\/p>"
  },
  "cljs.core\/catch": {
    "type": "special form",
    "signature": [
      "[exception-type name expr*]"
    ],
    "related": [
      "cljs.core\/try",
      "cljs.core\/finally",
      "cljs.core\/throw"
    ],
    "full-name": "cljs.core\/catch",
    "description-html": "<p><code>catch<\/code> should be used inside of a <code>try<\/code> expression.<\/p>\n<p><code>exception-type<\/code> should be the type of exception thrown (usually <code>js\/Error<\/code> or\n<code>js\/Object<\/code>). When there is a match, the thrown exception will be bound to\n<code>name<\/code> inside of <code>expr*<\/code> and <code>expr*<\/code> will be evaluated and returned as the value\nof the <code>try<\/code> expression.<\/p>"
  }
}
